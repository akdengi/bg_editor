  <style>
    /* Стили для рендеринга программы и алгоритма */

/* Контейнер для всей строки с двумя колонками */
.t005 .t-container .t-row {
    /* Убедимся, что строка растягивается */
    display: flex;
    flex-wrap: wrap;
    align-items: stretch; /* Выравнивание по высоте */
    height: 80vh; /* Высота 80% от высоты окна просмотра */
    min-height: 300px; /* Минимальная высота на случай очень маленьких экранов */
}

/* Стили для каждой колонки */
.t005 .t-container .t-row .t-col {
    /* Колонки тоже должны растягиваться по высоте */
    display: flex;
    flex-direction: column;
    height: 100%; /* Занимать всю высоту родительского .t-row */
    /* Добавим немного отступа между колонками */
    box-sizing: border-box;
    padding: 0 10px; /* Отступы слева и справа внутри колонки */
}

/* Убираем отступы у первой и последней колонки, если нужно прижать их к краям */
/* .t005 .t-container .t-row .t-col:first-child { padding-left: 0; } */
/* .t005 .t-container .t-row .t-col:last-child { padding-right: 0; } */


/* Стили для текстового контейнера внутри колонки (туда вставляется Blockly и алгоритм) */
.t005 .t-container .t-row .t-col .t005__text[field="text2"] {
    /* Контейнеры внутри колонок тоже растягиваются */
    display: flex;
    flex-direction: column;
    flex-grow: 1; /* Занимают всё доступное пространство внутри .t-col */
    height: 100%; /* 100% высоты родительской .t-col */
    /* Убираем внутренние отступы по умолчанию, если они есть */
    padding: 0;
    margin: 0;
    /* Граница и фон для наглядности */
    /* border: 1px solid #eee; */
    /* background-color: #fafafa; */
    overflow: hidden; /* Скрываем переполнение внутри этого контейнера */
}

/* Родительский контейнер для Blockly */
.t005 .t-container .t-row .t-col .t005__text[field="text"] {
    display: flex;
    flex-direction: column;
    flex-grow: 1;
    height: 100%;
    padding: 0;
    margin: 0;
    overflow: hidden; /* Скрываем переполнение */
}


/* КОНТЕЙНЕР ДЛЯ БЛОКЛИ */
#program-render-container {
    flex-grow: 1;
    width: 100%;
    height: auto !important;
    min-height: 200px;
    border: 1px solid #ccc;
    border-radius: 4px;
    background-color: #f9f9f9;
    overflow: auto; /* Включаем обе оси прокрутки */
    padding: 5px;
    box-sizing: border-box;
}

/* КОНТЕЙНЕР ДЛЯ АЛГОРИТМА */
#program-algorithm-container {
    /* Занимает всё доступное пространство внутри .t005__text[field="text2"] */
    flex-grow: 1;
    width: 100%;
    /* Высота теперь управляется flex-grow */
    height: auto !important; /* Перезаписываем возможные inline-стили */
    min-height: 100px;
    /* Стили шрифта и фона */
    font-family: 'Courier New', monospace;
    font-size: 14px;
    color: #333;
    line-height: 1.4;
    white-space: pre-wrap; /* Перенос строк */
    background-color: #f0f0f0;
    border: 1px solid #ddd;
    border-radius: 4px;
    /* ВАЖНО: overflow для скролла внутри контейнера */
    overflow-y: auto;
    overflow-x: auto; /* На случай длинных строк */
    padding: 10px;
    box-sizing: border-box;
    margin-top: 10px; /* Отступ сверху */
    margin-bottom: 10px; /* Отступ снизу перед кнопкой */
}


    #viewer-save-button {
      margin-top: 10px;
      padding: 8px 12px;
      background-color: #4CAF50;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 14px;
    }
    #viewer-save-button:hover {
      background-color: #45a049;
    }
    #viewer-info-message {
      margin-top: 10px;
      font-size: 14px;
      color: #666;
    }
    #viewer-info-message a {
      color: #1a0dab;
      text-decoration: underline;
    }
    #viewer-info-message a:hover {
      color: #1a0dab;
      text-decoration: none;
    }

    /* Стили для кнопок управления масштабом */
    .viewer-zoom-controls {
        position: absolute;
        top: 10px;
        right: 10px;
        z-index: 100;
        display: flex;
        gap: 5px;
    }
    .viewer-zoom-button {
        width: 50px;
        height: 50px;
        background-color: #fff;
        border: 1px solid #ccc;
        border-radius: 4px;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        font-weight: bold;
        user-select: none;
    }
    .viewer-zoom-button:hover {
        background-color: #f0f0f0;
    }
    .viewer-zoom-button:active {
        background-color: #e0e0e0;
    }

  </style>
  <script src="https://unpkg.com/blockly@12.2.0/blockly.min.js"></script>
  <script src="https://unpkg.com/blockly@12.2.0/msg/ru.js"></script>

<script>
  (function () {
    'use strict';
    // --- Вспомогательные функции ---
    const textToDom = function(text) {
      const parser = new DOMParser();
      const xml = parser.parseFromString(text, 'text/xml');
      return xml.documentElement;
    };
    const domToText = function(dom) {
      const serializer = new XMLSerializer();
      return serializer.serializeToString(dom);
    };
    // --- Определение блоков (только определения, без генераторов) ---
    Blockly.defineBlocksWithJsonArray([
      {
        "type": "bot_program",
        "message0": "=== Программа для Бота: %1 ===",
        "args0": [{ "type": "field_input", "name": "PROGRAM_NAME", "text": "Имя Бота" }],
        "message1": "%1",
        "args1": [{ "type": "input_statement", "name": "PROGRAM_LINES", "check": "ProgramLine" }],
        "colour": "#FF8C00",
        "tooltip": "Начальный блок программы бота. Можете задать Имя для Бота.",
        "previousStatement": null,
        "nextStatement": null
      },
      {
        "type": "bot_durability",
        "message0": "Прочность Бота %1 единиц Атаки",
        "args0": [{ "type": "field_dropdown", "name": "DURABILITY", "options": [["1", "1"], ["2", "2"], ["3", "3"], ["4", "4"]] }],
        "previousStatement": "ProgramLine", 
        "nextStatement": "ProgramLine",
        "colour": "#32CD32",
        "tooltip": "Устанавливает прочность бота (количество единиц атаки, которые он может выдержать).",
        "helpUrl": ""
      },
      {
        "type": "program_line_before",
        "message0": "Программа исполняется в начале раунда",
        "message1": "%1",
        "args1": [{ "type": "input_statement", "name": "SUBSTACK", "check": "Action" }],
        "previousStatement": "ProgramLine",
        "nextStatement": "ProgramLine",
        "tooltip": "Программа Бота исполняется ПОСЛЕ выкладывания Программ игроков, но ДО начала раунда и открытия первой строки Программ.",
        "colour": "#FF8C00"
      },
      {
        "type": "program_line_1",
        "message0": "Перед строкой Программ игроков 1",
        "message1": "%1",
        "args1": [{ "type": "input_statement", "name": "SUBSTACK", "check": "Action" }],
        "previousStatement": "ProgramLine",
        "nextStatement": "ProgramLine",
        "tooltip": "Этот участок Программы Бота  исполняется ДО открытия 1-й строки Программ игроков, но после начала раунда.",
        "colour": "#FF8C00"
      },
      {
        "type": "program_line_2",
        "message0": "Перед строкой Программ игроков 2",
        "message1": "%1",
        "args1": [{ "type": "input_statement", "name": "SUBSTACK", "check": "Action" }],
        "previousStatement": "ProgramLine",
        "nextStatement": "ProgramLine",
        "tooltip": "Этот участок Программы Бота  исполняется ДО открытия 2-й строки Программ игроков, но после исполнения 1-й строки",
        "colour": "#FF8C00"
      },
      {
        "type": "program_line_3",
        "message0": "Перед строкой Программ игроков 3",
        "message1": "%1",
        "args1": [{ "type": "input_statement", "name": "SUBSTACK", "check": "Action" }],
        "previousStatement": "ProgramLine",
        "nextStatement": "ProgramLine",
        "tooltip": "Этот участок Программы Бота  исполняется ДО открытия 3-й строки Программ игроков, но после исполнения 2-й строки",
        "colour": "#FF8C00"
      },
      {
        "type": "program_line_4",
        "message0": "Перед строкой Программ игроков 4",
        "message1": "%1",
        "args1": [{ "type": "input_statement", "name": "SUBSTACK", "check": "Action" }],
        "previousStatement": "ProgramLine",
        "nextStatement": "ProgramLine",
        "tooltip": "Этот участок Программы Бота  исполняется ДО открытия 4-й строки Программ игроков, но после исполнения 3-й строки",
        "colour": "#FF8C00"
      },
      {
        "type": "move_forward",
        "message0": "Идти %1 шагов",
        "args0": [{ "type": "field_dropdown", "name": "STEPS", "options": [["1", "1"], ["2", "2"], ["3", "3"], ["4", "4"]] }],
        "previousStatement": "Action",
        "nextStatement": "Action",
        "tooltip": "Идти вперед на N клеток.",
        "colour": "#5599FF"
      },
      {
        "type": "move_backward",
        "message0": "Идти -%1 шагов",
        "args0": [{ "type": "field_dropdown", "name": "STEPS", "options": [["1", "1"], ["2", "2"], ["3", "3"], ["4", "4"]] }],
        "previousStatement": "Action",
        "nextStatement": "Action",
        "tooltip": "Идти назад на N клеток.",
        "colour": "#5599FF"
      },
      {
        "type": "turn_right",
        "message0": "Повернуть ↻ на %1 градусов",
        "args0": [{ "type": "field_dropdown", "name": "DEGREES", "options": [["90", "90"], ["180", "180"]] }],
        "previousStatement": "Action",
        "nextStatement": "Action",
        "tooltip": "Повернуться на месте вправо на N градусов.",
        "colour": "#5599FF"
      },
      {
        "type": "turn_left",
        "message0": "Повернуть ↺ на %1 градусов",
        "args0": [{ "type": "field_dropdown", "name": "DEGREES", "options": [["90", "90"], ["180", "180"]] }],
        "previousStatement": "Action",
        "nextStatement": "Action",
        "tooltip": "Повернуться на месте влево на N градусов.",
        "colour": "#5599FF"
      },
      {
        "type": "stand_still",
        "message0": "Ждать до <следующая команда>",
        "previousStatement": "Action",
        "nextStatement": "Action",
        "tooltip": "Ничего не делать до следующей команды или строки команд",
        "colour": "#5599FF"
      },
      {
        "type": "attack",
        "message0": "Атака на %1",
        "args0": [{ "type": "field_dropdown", "name": "DISTANCE", "options": [["1","1"],["2","2"],["3","3"]] }],
        "previousStatement": "Action",
        "nextStatement": "Action",
        "tooltip": "Атаковать клетку перед собой на N единиц урона.",
        "colour": "#FF69B4"
      },
      {
        "type": "attack_force",
        "message0": "Атака на %1 силой %2",
        "args0": [
          { "type": "field_dropdown", "name": "DISTANCE", "options": [["1","1"],["2","2"],["3","3"]] },
          { "type": "field_dropdown", "name": "POWER", "options": [["1","1"],["2","2"]] }
        ],
        "previousStatement": "Action",
        "nextStatement": "Action",
        "tooltip": "Атаковать на N клеток перед собой на M единиц урона.",
        "colour": "#FF69B4"
      },
      {
        "type": "defend",
        "message0": "Защита на %1",
        "args0": [{ "type": "field_dropdown", "name": "DISTANCE", "options": [["1","1"],["2","2"],["3","3"]] }],
        "previousStatement": "Action",
        "nextStatement": "Action",
        "tooltip": "Защита от Атак силой до N единиц Урона. Если Атакуют несколько противников, то N = N1 + N2 + N3 + N4",
        "colour": "#FF69B4"
      },
      {
        "type": "freeze",
        "message0": "Заморозить",
        "previousStatement": "Action",
        "nextStatement": "Action",
        "tooltip": "Заморозить клетку перед собой. Если на клетке Вода, то положить на нее жетон Льда.",
        "colour": "#FF69B4"
      },
      {
        "type": "jump",
        "message0": "Прыжок на %1 клетки",
        "args0": [
          {
            "type": "field_dropdown",
            "name": "DISTANCE",
            "options": [
              ["2", "2"],
              ["3", "3"]
            ]
          }
        ],
        "previousStatement": "Action",
        "nextStatement": "Action",
        "tooltip": "Прыгнуть на расстояние 2 или 3 клетки, если на них нет Бочки, Робота или Камня или запрыгнуть на 1-2 Бочки.",
        "colour": "#FF69B4"
      },
      {
        "type": "throw_ai_dice",
        "message0": "Кинь AI кубик",
        "previousStatement": "Action",
        "nextStatement": "Action",
        "tooltip": "Кинуть AI-кубик и выполнить выпавшую команду.",      
        "colour": "#5599FF"
      },
      {
        "type": "enemy_present",
        "message0": "Вижу противника на расстоянии %1",
        "args0": [{ "type": "field_dropdown", "name": "DISTANCE", "options": [["1", "1"], ["2", "2"], ["3", "3"], ["4", "4"]] }],
        "output": "Boolean",
        "tooltip": "Проверка, есть ли в поле зрения на N клетках перед роботом Противник (другой Робот).",   
        "colour": "#32CD32"
      },
      {
        "type": "obstacle_present",
        "message0": "Препятствие = %1",
        "args0": [{ "type": "field_dropdown", "name": "STATE", "options": [["0","FALSE"],["1","TRUE"]] }],
        "output": "Boolean",
        "tooltip": "Проверка, есть ли на клетке перед Роботом препятствие. См. инструкцию, какие жетоны или фигурки к ним относятся.", 
        "colour": "#32CD32"
      },
      {
        "type": "weather_condition",
        "message0": "Сторона поля = %1",
        "args0": [{ "type": "field_dropdown", "name": "CONDITION", "options": [["Лето","SUMMER"],["Зима","WINTER"]] }],
        "output": "Boolean",
        "tooltip": "Определить, поле на котором стоит Бот Летнее или Зимнее (с заносами и гололедом).", 
        "colour": "#32CD32"
      },
      {
        "type": "damage_present",
        "message0": "Есть повреждения бота = %1",
        "args0": [{ "type": "field_dropdown", "name": "STATE", "options": [["0","FALSE"],["1","TRUE"]] }],
        "output": "Boolean",
        "tooltip": "Определить, есть ли у Бота какие то повреждения. Учет повреждений вам нужно вести самостоятельно.", 
        "colour": "#32CD32"
      },
      {
        "type": "water_hit",
        "message0": "Впереди вода = %1",
        "args0": [{ "type": "field_dropdown", "name": "STATE", "options": [["0","FALSE"],["1","TRUE"]] }],
        "output": "Boolean",
        "tooltip": "Определить, есть ли перед Ботом Вода.", 
        "colour": "#32CD32"
      },
      {
        "type": "can_attack",
        "message0": "Можно в Атаку = %1",
        "args0": [{ "type": "field_dropdown", "name": "STATE", "options": [["0", "FALSE"],["1", "TRUE"]]}],
        "output": "Boolean",
        "tooltip": "Определить, можно ли Атаковать клетку перед собой. Срабатывает, если там есть другой робот или препятствие, которое можно Атаковать.", 
        "colour": "#32CD32"
      },
      {
        "type": "custom_repeat",
        "message0": "Повторить %1 раз(а)",
        "args0": [{ "type": "field_number", "name": "TIMES", "value": 1, "min": 1, "max": 10 }],
        "message1": "%1",
        "args1": [{ "type": "input_statement", "name": "DO", "check": "Action" }],
        "previousStatement": "Action",
        "nextStatement": "Action",
        "tooltip": "Цикл повтора команд N раз (от 1 до 10)", 
        "colour": "#FF8C00"
      },
      {
        "type": "custom_if",
        "message0": "если %1 то %2",
        "args0": [
          { "type": "input_value", "name": "CONDITION", "check": "Boolean" },
          { "type": "input_statement", "name": "THEN", "check": "Action" }
        ],
        "message1": "иначе %1",
        "args1": [{ "type": "input_statement", "name": "ELSE", "check": "Action" }],
        "previousStatement": "Action",
        "nextStatement": "Action",
        "tooltip": "Условие если, то... иначе... Для срабатывания добавьте блоки из раздела Условия", 
        "colour": "#FF8C00"
      },
      {
        "type": "case_dice_roll",
        "message0": "Брось кубик и выполни:",
        "message1": "1: %1",
        "args1": [{ "type": "input_statement", "name": "CASE_1", "check": "Action" }],
        "message2": "2: %1",
        "args2": [{ "type": "input_statement", "name": "CASE_2", "check": "Action" }],
        "message3": "3: %1",
        "args3": [{ "type": "input_statement", "name": "CASE_3", "check": "Action" }],
        "message4": "4: %1",
        "args4": [{ "type": "input_statement", "name": "CASE_4", "check": "Action" }],
        "message5": "5: %1",
        "args5": [{ "type": "input_statement", "name": "CASE_5", "check": "Action" }],
        "message6": "6: %1",
        "args6": [{ "type": "input_statement", "name": "CASE_6", "check": "Action" }],
        "previousStatement": "Action",
        "nextStatement": "Action",
        "colour": "#FF8C00",
        "tooltip": "Блок Условных действий (CASE), где вариант выбирается по броску кубика (1-6).",
        "helpUrl": ""
      }
    ]);

    // --- Генерация читаемого алгоритма ---
    function generateReadableAlgorithm(workspace) {
      const lines = [];
      function traverseBlock(block, indent = 0) {
          if (!block) return;
          const prefix = "  ".repeat(indent);
          let text = "";
          switch (block.type) {
          case 'bot_durability':
              text = `Прочность Бота ${block.getFieldValue('DURABILITY')} единиц Атаки`;
              break;
          case 'program_line_before':
              text = 'Программа Бота исполняется в начале раунда';
              break;
          case 'program_line_1':
              text = 'Перед 1-й строкой Программ игроков';
              break;
          case 'program_line_2':
              text = 'Перед 2-й строкой Программ игроков';
              break;
          case 'program_line_3':
              text = 'Перед 3-й строкой Программ игроков';
              break;
          case 'program_line_4':
              text = 'Перед 4-й строкой Программ игроков';
              break;
          case 'move_forward':
              text = `Вперед на ${block.getFieldValue('STEPS')} шагов`;
              break;
          case 'move_backward':
              text = `Назад на ${block.getFieldValue('STEPS')} шагов`;
              break;
          case 'turn_right':
              text = `Поворот Вправо на ${block.getFieldValue('DEGREES')} градусов`;
              break;
          case 'turn_left':
              text = `Поворот Влево на ${block.getFieldValue('DEGREES')} градусов`;
              break;
          case 'stand_still':
              text = `Стоять на месте`;
              break;
          case 'throw_ai_dice':
              text = `Кинуть AI кубик`;
              break;
          case 'attack':
              text = `Атака на ${block.getFieldValue('DISTANCE')} клеток`;
              break;
          case 'attack_force':
              text = `Атака на ${block.getFieldValue('DISTANCE')} клеток силой ${block.getFieldValue('POWER')}`;
              break;
          case 'defend':
              text = `Защита на ${block.getFieldValue('DISTANCE')}`;
              break;
          case 'freeze':
              text = `Заморозить`;
              break;
          case 'jump':
              text = `Прыжок на ${block.getFieldValue('DISTANCE')} клетки`;
              break;
          case 'custom_repeat':
              text = `Повторить ${block.getFieldValue('TIMES')} раз(а)`;
              lines.push(prefix + text);
              const doBlock = block.getInputTargetBlock('DO');
              if (doBlock) {
              traverseStack(doBlock, indent + 1);
              }
              return;
          case 'custom_if':
              const conditionBlock = block.getInputTargetBlock('CONDITION');
              let condText = "условие";
              if (conditionBlock) condText = describeCondition(conditionBlock);
              lines.push(prefix + `Если ${condText}, то`);
              const thenBlock = block.getInputTargetBlock('THEN');
              if (thenBlock) {
              traverseStack(thenBlock, indent + 1);
              }
              const elseBlock = block.getInputTargetBlock('ELSE');
              if (elseBlock) {
              lines.push(prefix + "иначе");
              traverseStack(elseBlock, indent + 1);
              }
              return;
          case 'case_dice_roll':
              text = 'Брось кубики и выполни согласно выпавшему числу:';
              lines.push(prefix + text);
              for (let i = 1; i <= 6; i++) {
                  const caseBlock = block.getInputTargetBlock(`CASE_${i}`);
                  if (caseBlock) {
                      lines.push(prefix + `  "${i}":`);
                      traverseStack(caseBlock, indent + 2);
                  } else {
                       lines.push(prefix + `  "${i}":`);
                       lines.push(prefix + `    // Нет команды`);
                  }
              }
              return;
          default:
              text = block.type.replace(/_/g, ' ');
          }
          lines.push(prefix + text);
      }
      function traverseStack(block, indent = 0) {
          while (block) {
          traverseBlock(block, indent);
          block = block.getNextBlock();
          }
      }
      function describeCondition(block) {
          switch (block.type) {
          case 'enemy_present':
              return `Вижу противника на расстоянии ${block.getFieldValue('DISTANCE')} клеток`;
          case 'obstacle_present':
              return `Препятствие = ${block.getFieldValue('STATE') === 'TRUE' ? 'Да' : 'Нет'}`;
          case 'weather_condition':
              return `Сторона поля = ${block.getFieldValue('CONDITION')}`;
          case 'damage_present':
              return `Есть повреждения бота = ${block.getFieldValue('STATE') === 'TRUE' ? 'Да' : 'Нет'}`;
          case 'water_hit':
              return `Впереди вода = ${block.getFieldValue('STATE') === 'TRUE' ? 'Да' : 'Нет'}`;
          case 'can_attack':
              return `Можно в Атаку = ${block.getFieldValue('STATE') === 'TRUE' ? 'Да' : 'Нет'}`;
          default:
              return "условие";
          }
      }
      const root = workspace.getTopBlocks(false).find(b => b.type === 'bot_program');
      if (root) {
          // Убираем добавление строки с именем бота в алгоритм
          // Она теперь будет выводиться в заголовке H3
          const firstLine = root.getInputTargetBlock('PROGRAM_LINES');
          if (firstLine) {
              let currentLine = firstLine;
              while (currentLine) {
                  traverseBlock(currentLine, 0);
                  const substack = currentLine.getInputTargetBlock('SUBSTACK');
                  if (substack) {
                      traverseStack(substack, 1);
                  }
                  currentLine = currentLine.getNextBlock();
              }
          }
      }
      return lines.length > 0 ? lines.join('\n') : "// Алгоритм пуст";
    }
    // --- Основная функция инициализации вьювера ---
    function initViewer() {
      // 1. Найти контейнеры на странице по атрибуту field
      const blocklyContainer = document.querySelector('.t005 .t-container .t-row .t-col .t005__text[field="text"]');
      const algorithmContainer = document.querySelector('.t005 .t-container .t-row .t-col .t005__text[field="text2"]');

      if (!blocklyContainer) {
          console.warn('Контейнер .t005__text[field="text"] для Blockly не найден на странице.');
          return;
      }
      if (!algorithmContainer) {
          console.warn('Контейнер .t005__text[field="text2"] для алгоритма не найден на странице.');
          return;
      }

      // 2. Получить XML данные из контейнера field="text"
      let xmlText = "";
      try {
          let htmlContent = blocklyContainer.innerHTML || blocklyContainer.textContent || blocklyContainer.innerText;
          // Проверим, начинается ли оно с '&lt;xml' (HTML-сущности для <xml)
          if (htmlContent && htmlContent.trim().startsWith("&lt;xml")) {
              // Декодируем HTML-сущности
              const textarea = document.createElement('textarea');
              textarea.innerHTML = htmlContent;
              xmlText = textarea.value;
          } else if (htmlContent && htmlContent.includes('<xml')) {
              // Если уже декодировано (например, при тестировании)
              xmlText = htmlContent;
          } else {
              // Попробуем получить текст напрямую
              xmlText = htmlContent;
          }
      } catch (e) {
          console.error("Ошибка при извлечении XML из контейнера:", e);
      }

      if (!xmlText || !xmlText.trim() || !xmlText.includes('<xml')) {
           console.warn('XML данные не найдены или пусты внутри .t005__text[field="text"].');
           blocklyContainer.innerHTML = "<p style='color:red;'>Ошибка: XML данные программы не найдены или некорректны.</p>";
           algorithmContainer.textContent = "// Ошибка загрузки";
           return;
      }

      try {
          const xmlDom = textToDom(xmlText);
          
          // 3. Очистить контейнеры перед добавлением новых элементов
          blocklyContainer.innerHTML = ''; 
          // algorithmContainer.innerHTML = ''; // Не очищаем полностью, так как туда пойдет только текст

          // 4. Создать временный workspace для рендеринга
          const renderDiv = document.createElement('div');
          renderDiv.id = 'program-render-container';
          renderDiv.style.position = 'relative';
          renderDiv.style.width = '100%';
          renderDiv.style.height = 'auto';
          renderDiv.style.overflow = 'hidden';
          renderDiv.style.minHeight = '200px'; // Минимальная высота для workspace

          // Создаем скрытый div для workspace
          const workspaceDiv = document.createElement('div');
          workspaceDiv.id = 'viewer-workspace';
          workspaceDiv.style.position = 'absolute';
          workspaceDiv.style.top = '0';
          workspaceDiv.style.left = '0';
          workspaceDiv.style.width = '100%';
          workspaceDiv.style.height = '100%';
          renderDiv.appendChild(workspaceDiv);
          
          blocklyContainer.appendChild(renderDiv);
          
          // Убираем установку className, так как infoContainer уже имеет нужные классы
          // blocklyContainer.className = 't005__text t-text t-text_md';

        const viewerWorkspace = Blockly.inject('viewer-workspace', {
            readOnly: true,
            toolbox: null,
            trashcan: false,
            // Установите желаемый начальный масштаб, например, 0.9 (90%)
            zoom: { controls: false, wheel: false, startScale: 0.9, maxScale: 3, minScale: 0.3 },
            scrollbars: true,
            grid: { spacing: 20, length: 1, colour: '#ddd', snap: false },
            disableAutoRendering: true,
            renderer: 'zelos'
        });

      // Добавляем кнопки управления масштабом
      const zoomControls = document.createElement('div');
      zoomControls.className = 'viewer-zoom-controls';
      
      // Кнопка увеличения масштаба (+)
      const zoomInButton = document.createElement('div');
      zoomInButton.className = 'viewer-zoom-button';
      zoomInButton.textContent = '+';
      zoomInButton.title = 'Увеличить масштаб';
      zoomInButton.onclick = function() {
          const currentScale = viewerWorkspace.getScale();
          const newScale = Math.min(currentScale + 0.1, 3); // Максимальный масштаб 3
          viewerWorkspace.setScale(newScale);
      };
      zoomControls.appendChild(zoomInButton);
      
      // Кнопка уменьшения масштаба (-)
      const zoomOutButton = document.createElement('div');
      zoomOutButton.className = 'viewer-zoom-button';
      zoomOutButton.textContent = '-';
      zoomOutButton.title = 'Уменьшить масштаб';
      zoomOutButton.onclick = function() {
          const currentScale = viewerWorkspace.getScale();
          const newScale = Math.max(currentScale - 0.1, 0.3); // Минимальный масштаб 0.3
          viewerWorkspace.setScale(newScale);
      };
      zoomControls.appendChild(zoomOutButton);
      
      // Кнопка центровки
      const centerButton = document.createElement('div');
      centerButton.className = 'viewer-zoom-button';
      centerButton.textContent = '⌂';
      centerButton.title = 'Центрировать программу';
      centerButton.onclick = function() {
          viewerWorkspace.zoomToFit();
      };
      zoomControls.appendChild(centerButton);
      
      renderDiv.appendChild(zoomControls);
          
          // 5. Загрузить XML в workspace
          Blockly.Xml.domToWorkspace(xmlDom, viewerWorkspace);
          
          // 6. Принудительно отрендерить workspace после загрузки
          setTimeout(() => {
               try {
                   viewerWorkspace.render();
                   // После рендеринга пытаемся прокрутить к верху программы
                   const topBlocks = viewerWorkspace.getTopBlocks(true);
                   if (topBlocks.length > 0) {
                       // Прокручиваем в начало
                       viewerWorkspace.zoomToFit(); 
                   }
               } catch (e) {
                    console.error("Ошибка при принудительном рендеринге Blockly:", e);
               }
          }, 100); // Небольшая задержка для уверенности
          

          // 7. Заполнить контейнер для алгоритма
          const readableAlgorithm = generateReadableAlgorithm(viewerWorkspace);
          
          // Создаем контейнер для заголовка с центровкой
          const headerContainer = document.createElement('div');
          headerContainer.style.textAlign = 'center'; // Центрируем содержимое
          headerContainer.style.margin = '0 0 10px 0';
          headerContainer.style.padding = '0';
          
          // Создаем заголовок H3 с именем бота
          const botNameHeader = document.createElement('h3');
          botNameHeader.style.margin = '0';
          botNameHeader.style.padding = '0';
          botNameHeader.style.display = 'inline-block'; // Чтобы центровка работала
          botNameHeader.style.fontSize = '1.17em';
          botNameHeader.style.fontWeight = 'bold';
          
          // Получаем имя бота из корневого блока
          let botName = "Ледяной Страж-Бот 1"; // значение по умолчанию
          const rootBlock = viewerWorkspace.getTopBlocks(false).find(b => b.type === 'bot_program');
          if (rootBlock) {
              const nameField = rootBlock.getFieldValue('PROGRAM_NAME')?.trim();
              if (nameField) {
                  botName = nameField;
              }
          }
          botNameHeader.textContent = `=== Программа для Бота: ${botName} ===`;
          
          // Добавляем заголовок в контейнер
          headerContainer.appendChild(botNameHeader);
          
          // Очищаем контейнер алгоритма и добавляем элементы
          algorithmContainer.innerHTML = '';
          algorithmContainer.appendChild(headerContainer); // Добавляем центрированный заголовок
          
          // Добавляем блок с алгоритмом
          const algorithmPre = document.createElement('pre');
          algorithmPre.id = 'program-algorithm-container';
          algorithmPre.style.cssText = 'margin: 0; padding: 10px; font-family: \'Courier New\', monospace; font-size: 14px; color: #333; white-space: pre-wrap; line-height: 1.4; background-color: #f0f0f0; border: 1px solid #ddd; border-radius: 4px; max-height: 60vh; overflow-y: auto;';
          algorithmPre.textContent = Blockly.utils.string.wrap(readableAlgorithm, 60);
          algorithmContainer.appendChild(algorithmPre);

          // 8. Создать кнопку "Сохранить .bot"
          const saveButton = document.createElement('button');
          saveButton.id = 'viewer-save-button';
          saveButton.textContent = 'Сохранить Программу (.bot)';
          saveButton.style.cssText = 'margin-top: 10px; padding: 8px 12px; background-color: #4CAF50; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 14px;';
          saveButton.onmouseover = function() { this.style.backgroundColor = '#45a049'; };
          saveButton.onmouseout = function() { this.style.backgroundColor = '#4CAF50'; };
          saveButton.onclick = function() {
              try {
                  // --- Получение имени бота из корневого блока ---
                  let fileNameBase = "Программа для бота";
                  const rootBlock = viewerWorkspace.getTopBlocks(false).find(b => b.type === 'bot_program');
                  if (rootBlock) {
                    const botName = rootBlock.getFieldValue('PROGRAM_NAME')?.trim();
                    if (botName) {
                      fileNameBase = `Программа для бота ${botName}`.replace(/[/\\?%*:|"<>]/g, '_');
                    }
                  }
                  const fileName = `${fileNameBase}.bot`;
                  // ---------------------------------------------
                  const blob = new Blob([xmlText], { type: 'text/xml' });
                  const url = URL.createObjectURL(blob);
                  const a = document.createElement('a');
                  a.href = url;
                  a.download = fileName;
                  // Программный клик по ссылке
                  document.body.appendChild(a); // Firefox требует, чтобы элемент был в DOM
                  a.click();
                  document.body.removeChild(a);
                  URL.revokeObjectURL(url);
                  // alert(`Программа сохранена в файл "${fileName}"`);
              } catch (err) {
                  console.error("Ошибка при сохранении файла:", err);
                  alert("Не удалось сохранить файл. Проверьте консоль браузера.");
              }
          };
          algorithmContainer.appendChild(saveButton);
          
          // 9. Добавить информационное сообщение
          const infoMessage = document.createElement('div');
          infoMessage.id = 'viewer-info-message';
          infoMessage.innerHTML = 'Для экспорта в PDF и PNG откройте .bot файл <a href="https://simplrobot.ru/bg4_bot_editor" target="_blank" rel="noopener noreferrer">в редакторе</a>.';
          infoMessage.style.cssText = 'margin-top: 10px; font-size: 14px; color: #666;';
          const linkStyle = 'color: #1a0dab; text-decoration: underline;';
          const linkHoverStyle = 'color: #1a0dab; text-decoration: none;';
          infoMessage.querySelector('a').style.cssText = linkStyle;
          infoMessage.querySelector('a').onmouseover = function() { this.style.cssText = linkHoverStyle; };
          infoMessage.querySelector('a').onmouseout = function() { this.style.cssText = linkStyle; };
          algorithmContainer.appendChild(infoMessage);
          
       } catch (e) {
          console.error("Ошибка при парсинге XML или инициализации Blockly:", e);
          blocklyContainer.innerHTML = `<p style="color: red;">Ошибка: Невозможно отобразить программу. Некорректные данные. (${e.message})</p>`;
          algorithmContainer.textContent = `// Ошибка: ${e.message}`;
       }
    }
    // --- Запуск после загрузки страницы ---
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', initViewer);
    } else {
      initViewer();
    }
  })();
</script>