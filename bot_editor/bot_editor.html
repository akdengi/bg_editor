<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Редактор программ для Ботов Битвы Големов v0.0.1</title>
  <meta http-equiv="Content-Language" content="ru">
  <meta name="google" content="notranslate">
<style>
  html, body {
    height: 100%;
    margin: 0;
    padding: 0;
    overflow: hidden;
    font-family: Arial, sans-serif;
  }
    #blocklyDiv {
    position: absolute;
    top: 0;
    left: 10px;
    right: 10px;
    /* Будет устанавливаться динамически — см. onresize */
    height: calc(90% - 80px);
    z-index: 1;
    }
  .button-container {
    position: absolute;
    bottom: 10px;
    left: 10px;
    display: flex;
    gap: 10px;
    z-index: 1000;
  }
  .button-container button {
    padding: 8px 12px;
    background-color: #4CAF50;
    color: white;
    border: none;
    border-radius: 4px;
    cursor: pointer;
    font-size: 14px;
  }
  .button-container button:hover {
    background-color: #45a049;
  }

    #algorithmOutput {
    position: absolute;
    top: calc(90% - 80px); /* Начинается чуть выше нижней части */
    left: 10px;
    right: 10px;
    height: 80px;
    min-height: 60px;
    max-height: 300px;
    overflow-y: auto;
    background-color: #f9f9f9;
    border: 1px solid #ddd;
    border-radius: 4px;
    padding: 10px;
    font-family: 'Courier New', monospace;
    font-size: 14px;
    color: #333;
    white-space: pre;
    line-height: 1.4;
    z-index: 999;
    box-sizing: border-box;
    resize: vertical;
    /* Ключевое: делаем ресайз через ::before для верхнего края */
    cursor: ns-resize;
    }

    /* Добавляем "ручку" для ресайза сверху */
    #algorithmOutput::before {
    content: "";
    display: block;
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 5px;
    background: #aaa;
    cursor: ns-resize;
    z-index: 1000;
    }

</style>
  <script src="https://unpkg.com/blockly@12.2.0/blockly.min.js"></script>
  <script src="https://unpkg.com/blockly@12.2.0/msg/ru.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdfmake/0.2.12/pdfmake.min.js" integrity="sha512-axXaF5grZBaYl7qiM6OMHgsgVXdSLxqq0w7F4CQxuFyrcPmn0JfnqsOtYHUun80g6mRRdvJDrTCyL8LQqBOt/Q==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdfmake/0.2.12/vfs_fonts.min.js" integrity="sha512-EFlschXPq/G5zunGPRSYqazR1CMKj0cQc8v6eMrQwybxgIbhsfoO5NAMQX3xFDQIbFlViv53o7Hy+yCWw6iZxA==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
  <script src="https://22176.hostkey.in:34172/pictures/bg_editor/html2canvas.min.js"></script>
</head>
<body>
  <div id="blocklyDiv"></div>
  <div class="button-container">
    <button id="saveButton">Сохранить Программу</button>
    <button id="loadButton">Загрузить Программу</button>
    <button id="newProgramButton">Новая программа</button>
    <button id="exportPdfButton">Экспорт в PDF</button>
  </div>
  <div id="algorithmOutput">// Алгоритм будет здесь...</div>

<xml id="toolbox" style="display: none">
  <category name="Программа" colour="#FF8C00">
    <block type="bot_program"></block>
    <block type="program_line_before"></block>
    <block type="program_line_1"></block>
    <block type="program_line_2"></block>
    <block type="program_line_3"></block>
    <block type="program_line_4"></block>
  </category>
  <category name="Движение" colour="#5599FF">
    <block type="move_forward"></block>
    <block type="move_backward"></block>
    <block type="turn_right"></block>
    <block type="turn_left"></block>
    <block type="stand_still"></block>
    <block type="throw_ai_dice"></block>
  </category>
  <category name="Действия" colour="#FF69B4">
    <block type="attack"></block>
    <block type="attack_force"></block>
    <block type="defend"></block>
    <block type="freeze"></block>
    <block type="jump"></block>
  </category>
  <category name="Бонус-действия" colour="#FF8C00">
    <block type="custom_repeat"></block>
    <block type="custom_if"></block>
  </category>
  <category name="Условия" colour="#32CD32">
    <block type="enemy_present"></block>
    <block type="obstacle_present"></block>
    <block type="weather_condition"></block>
    <block type="damage_present"></block>
    <block type="water_hit"></block>
    <block type="can_attack"></block>
  </category>
</xml>

<script>
  // --- Перевод контекстного меню ---
  Blockly.Msg["DELETE_BLOCK"] = "Удалить блок";
  Blockly.Msg["DELETE_X_BLOCKS"] = "Удалить %1 блоков";
  Blockly.Msg["DUPLICATE_BLOCK"] = "Дублировать";
  Blockly.Msg["ADD_COMMENT"] = "Добавить комментарий";
  Blockly.Msg["REMOVE_COMMENT"] = "Удалить комментарий";
  Blockly.Msg["INLINE_INPUTS"] = "Встроенные входы";
  Blockly.Msg["EXTERNAL_INPUTS"] = "Внешние входы";
  Blockly.Msg["COLLAPSE_BLOCK"] = "Свернуть блок";
  Blockly.Msg["EXPAND_BLOCK"] = "Развернуть блок";
  Blockly.Msg["DISABLE_BLOCK"] = "Отключить блок";
  Blockly.Msg["ENABLE_BLOCK"] = "Включить блок";
  Blockly.Msg["HELP"] = "Помощь";

  // --- Определение блоков ---
  Blockly.defineBlocksWithJsonArray([
    {
      "type": "bot_program",
      "message0": "=== Программа для Бота: %1 ===",
      "args0": [{ "type": "field_input", "name": "PROGRAM_NAME", "text": "Имя Бота" }],
      "message1": "%1",
      "args1": [{ "type": "input_statement", "name": "PROGRAM_LINES", "check": "ProgramLine" }],
      "colour": "#FF8C00",
      "tooltip": "Начальный блок программы бота.",
      "previousStatement": null,
      "nextStatement": null
    },
    {
      "type": "program_line_before",
      "message0": "Программа исполняется в начале раунда",
      "message1": "%1",
      "args1": [{ "type": "input_statement", "name": "SUBSTACK", "check": "Action" }],
      "previousStatement": "ProgramLine",
      "nextStatement": "ProgramLine",
      "colour": "#FF8C00"
    },
    {
      "type": "program_line_1",
      "message0": "Строка Программы 1",
      "message1": "%1",
      "args1": [{ "type": "input_statement", "name": "SUBSTACK", "check": "Action" }],
      "previousStatement": "ProgramLine",
      "nextStatement": "ProgramLine",
      "colour": "#FF8C00"
    },
    {
      "type": "program_line_2",
      "message0": "Строка Программы 2",
      "message1": "%1",
      "args1": [{ "type": "input_statement", "name": "SUBSTACK", "check": "Action" }],
      "previousStatement": "ProgramLine",
      "nextStatement": "ProgramLine",
      "colour": "#FF8C00"
    },
    {
      "type": "program_line_3",
      "message0": "Строка Программы 3",
      "message1": "%1",
      "args1": [{ "type": "input_statement", "name": "SUBSTACK", "check": "Action" }],
      "previousStatement": "ProgramLine",
      "nextStatement": "ProgramLine",
      "colour": "#FF8C00"
    },
    {
      "type": "program_line_4",
      "message0": "Строка Программы 4",
      "message1": "%1",
      "args1": [{ "type": "input_statement", "name": "SUBSTACK", "check": "Action" }],
      "previousStatement": "ProgramLine",
      "nextStatement": "ProgramLine",
      "colour": "#FF8C00"
    },
    {
      "type": "move_forward",
      "message0": "Идти %1 шагов",
      "args0": [{ "type": "field_number", "name": "STEPS", "value": 1, "min": 1, "max": 3 }],
      "previousStatement": "Action",
      "nextStatement": "Action",
      "colour": "#5599FF"
    },
    {
      "type": "move_backward",
      "message0": "Идти -%1 шагов",
      "args0": [{ "type": "field_number", "name": "STEPS", "value": 1, "min": 1, "max": 3 }],
      "previousStatement": "Action",
      "nextStatement": "Action",
      "colour": "#5599FF"
    },
    {
      "type": "turn_right",
      "message0": "Повернуть ↻ на %1 градусов",
      "args0": [{ "type": "field_dropdown", "name": "DEGREES", "options": [["90", "90"], ["180", "180"]] }],
      "previousStatement": "Action",
      "nextStatement": "Action",
      "colour": "#5599FF"
    },
    {
      "type": "turn_left",
      "message0": "Повернуть ↺ на %1 градусов",
      "args0": [{ "type": "field_dropdown", "name": "DEGREES", "options": [["90", "90"], ["180", "180"]] }],
      "previousStatement": "Action",
      "nextStatement": "Action",
      "colour": "#5599FF"
    },
    {
      "type": "stand_still",
      "message0": "Ждать до <следующая команда>",
      "previousStatement": "Action",
      "nextStatement": "Action",
      "colour": "#5599FF"
    },
    {
      "type": "attack",
      "message0": "Атака на %1",
      "args0": [{ "type": "field_dropdown", "name": "DISTANCE", "options": [["1","1"],["2","2"],["3","3"]] }],
      "previousStatement": "Action",
      "nextStatement": "Action",
      "colour": "#FF69B4"
    },
    {
      "type": "attack_force",
      "message0": "Атака на %1 силой %2",
      "args0": [
        { "type": "field_dropdown", "name": "DISTANCE", "options": [["1","1"],["2","2"],["3","3"]] },
        { "type": "field_dropdown", "name": "POWER", "options": [["1","1"],["2","2"]] }
      ],
      "previousStatement": "Action",
      "nextStatement": "Action",
      "colour": "#FF69B4"
    },
    {
      "type": "defend",
      "message0": "Защита на %1",
      "args0": [{ "type": "field_dropdown", "name": "DISTANCE", "options": [["1","1"],["2","2"],["3","3"]] }],
      "previousStatement": "Action",
      "nextStatement": "Action",
      "colour": "#FF69B4"
    },
    {
      "type": "freeze",
      "message0": "Заморозить",
      "previousStatement": "Action",
      "nextStatement": "Action",
      "colour": "#FF69B4"
    },
    {
      "type": "jump",
      "message0": "Подпрыгнуть",
      "previousStatement": "Action",
      "nextStatement": "Action",
      "colour": "#FF69B4"
    },
    {
      "type": "throw_ai_dice",
      "message0": "Кинь AI кубик",
      "previousStatement": "Action",
      "nextStatement": "Action",
      "colour": "#5599FF"
    },
    {
      "type": "enemy_present",
      "message0": "Вижу противника на расстоянии %1",
      "args0": [{ "type": "field_dropdown", "name": "DISTANCE", "options": [["1", "1"], ["2", "2"], ["3", "3"], ["4", "4"]] }],
      "output": "Boolean",
      "colour": "#32CD32"
    },
    {
      "type": "obstacle_present",
      "message0": "Препятствие = %1",
      "args0": [{ "type": "field_dropdown", "name": "STATE", "options": [["0","FALSE"],["1","TRUE"]] }],
      "output": "Boolean",
      "colour": "#32CD32"
    },
    {
      "type": "weather_condition",
      "message0": "Сторона поля = %1",
      "args0": [{ "type": "field_dropdown", "name": "CONDITION", "options": [["Лето","SUMMER"],["Зима","WINTER"]] }],
      "output": "Boolean",
      "colour": "#32CD32"
    },
    {
      "type": "damage_present",
      "message0": "Есть повреждения бота = %1",
      "args0": [{ "type": "field_dropdown", "name": "STATE", "options": [["0","FALSE"],["1","TRUE"]] }],
      "output": "Boolean",
      "colour": "#32CD32"
    },
    {
      "type": "water_hit",
      "message0": "Попадание в воду = %1",
      "args0": [{ "type": "field_dropdown", "name": "STATE", "options": [["0","FALSE"],["1","TRUE"]] }],
      "output": "Boolean",
      "colour": "#32CD32"
    },
    {
      "type": "can_attack",
      "message0": "Можно в Атаку = %1",
      "args0": [{ "type": "field_dropdown", "name": "STATE", "options": [["0", "FALSE"],["1", "TRUE"]]}],
      "output": "Boolean",
      "colour": "#32CD32"
    },
    {
      "type": "custom_repeat",
      "message0": "Повторить %1 раз(а)",
      "args0": [{ "type": "field_number", "name": "TIMES", "value": 1, "min": 1, "max": 10 }],
      "message1": "%1",
      "args1": [{ "type": "input_statement", "name": "DO", "check": "Action" }],
      "previousStatement": "Action",
      "nextStatement": "Action",
      "colour": "#FF8C00"
    },
    {
      "type": "custom_if",
      "message0": "если %1 то %2",
      "args0": [
        { "type": "input_value", "name": "CONDITION", "check": "Boolean" },
        { "type": "input_statement", "name": "THEN", "check": "Action" }
      ],
      "message1": "иначе %1",
      "args1": [{ "type": "input_statement", "name": "ELSE", "check": "Action" }],
      "previousStatement": "Action",
      "nextStatement": "Action",
      "colour": "#FF8C00"
    }
  ]);

    let workspace = null;
    const onresize = () => {
    const blocklyDiv = document.getElementById('blocklyDiv');
    const algorithmOutput = document.getElementById('algorithmOutput');
    const buttonAreaHeight = 60;
    const outputHeight = algorithmOutput.offsetHeight; // <- Использует текущую высоту
    const outputTop = algorithmOutput.offsetTop;       // <- Использует текущую позицию
    // Высота blocklyDiv = от верха до верха зоны алгоритма
    blocklyDiv.style.height = outputTop + 'px'; // <- Устанавливает высоту BlocklyDiv
    Blockly.svgResize(workspace);
    };

  // --- Функция для создания дефолтных блоков ---
  function createDefaultBlocks() {
    const rootBlock = workspace.newBlock('bot_program');
    rootBlock.getField('PROGRAM_NAME').setValue('Мой Бот');
    rootBlock.initSvg();
    rootBlock.render();

    const line1 = workspace.newBlock('program_line_before');
    line1.initSvg();
    line1.render();

    rootBlock.getInput('PROGRAM_LINES').connection.connect(line1.previousConnection);
    rootBlock.moveBy(50, 50);
  }

  // --- Ограничение: только один экземпляр каждого program_line_* блока ---
  function enforceUniqueProgramLines() {
    const allowedTypes = ['program_line_before', 'program_line_1', 'program_line_2', 'program_line_3', 'program_line_4'];
    const usedTypes = new Set();

    const allBlocks = workspace.getAllBlocks(false);
    for (const block of allBlocks) {
      if (allowedTypes.includes(block.type)) {
        if (usedTypes.has(block.type)) {
          block.dispose(); // Удаляем дубликат
        } else {
          usedTypes.add(block.type);
        }
      }
    }
  }

  // --- Генератор JavaScript ---
  const javascriptGenerator = Blockly.JavaScript;

  // Генераторы (остаются без изменений)
  javascriptGenerator['bot_program'] = function(block) {
    const programName = block.getFieldValue('PROGRAM_NAME');
    const substack = javascriptGenerator.statementToCode(block, 'PROGRAM_LINES') || '';
    return `// === Программа Бота: ${programName} ===\n${substack}`;
  };

  ['program_line_before', 'program_line_1', 'program_line_2', 'program_line_3', 'program_line_4'].forEach((type, i) => {
    javascriptGenerator[type] = function(block) {
      const substack = javascriptGenerator.statementToCode(block, 'SUBSTACK') || '';
      return `// --- Строка Программы ${i+1} ---\n${substack}`;
    };
  });

  // Остальные генераторы (не меняем)
  javascriptGenerator['move_forward'] = (block) => `moveForward(${block.getFieldValue('STEPS')});\n`;
  javascriptGenerator['move_backward'] = (block) => `moveBackward(${block.getFieldValue('STEPS')});\n`;
  javascriptGenerator['turn_right'] = (block) => `turnRight(${block.getFieldValue('DEGREES')});\n`;
  javascriptGenerator['turn_left'] = (block) => `turnLeft(${block.getFieldValue('DEGREES')});\n`;
  javascriptGenerator['stand_still'] = () => `standStill();\n`;
  javascriptGenerator['attack'] = (block) => `attack(${block.getFieldValue('DISTANCE')});\n`;
  javascriptGenerator['attack_force'] = (block) => `attack(${block.getFieldValue('DISTANCE')}, ${block.getFieldValue('POWER')});\n`;
  javascriptGenerator['defend'] = (block) => `defend(${block.getFieldValue('DISTANCE')});\n`;
  javascriptGenerator['freeze'] = () => `freeze();\n`;
  javascriptGenerator['jump'] = () => `jump();\n`;
  javascriptGenerator['throw_ai_dice'] = () => `throwAIDice();\n`;
  javascriptGenerator['custom_repeat'] = function(block) {
    const times = block.getFieldValue('TIMES');
    const doBlock = javascriptGenerator.statementToCode(block, 'DO') || '';
    return `repeat(${times}, function() {\n  ${doBlock}});\n`;
  };
  javascriptGenerator['custom_if'] = function(block) {
    const condition = javascriptGenerator.valueToCode(block, 'CONDITION', javascriptGenerator.ORDER_NONE) || 'false';
    const thenCode = javascriptGenerator.statementToCode(block, 'THEN') || '';
    const elseCode = javascriptGenerator.statementToCode(block, 'ELSE') || '';
    return `if (${condition}) {\n  ${thenCode}} else {\n  ${elseCode}\n}\n`;
  };

  // --- Генерация читаемого алгоритма ---
    function generateReadableAlgorithm() {
    const output = document.getElementById('algorithmOutput');
    const lines = [];

    function traverseBlock(block, indent = 0) {
        if (!block) return;
        const prefix = "  ".repeat(indent); // ← Теперь табуляция (Python style)
        let text = "";

        switch (block.type) {
        case 'program_line_before':
            text = 'Программа исполняется в начале раунда';
            break;
        case 'program_line_1':
            text = 'Строка программы 1';
            break;
        case 'program_line_2':
            text = 'Строка программы 2';
            break;
        case 'program_line_3':
            text = 'Строка программы 3';
            break;
        case 'program_line_4':
            text = 'Строка программы 4';
            break;
        case 'move_forward':
            text = `Вперед на ${block.getFieldValue('STEPS')} шагов`;
            break;
        case 'move_backward':
            text = `Назад на ${block.getFieldValue('STEPS')} шагов`;
            break;
        case 'turn_right':
            text = `Поворот Вправо на ${block.getFieldValue('DEGREES')} градусов`;
            break;
        case 'turn_left':
            text = `Поворот Влево на ${block.getFieldValue('DEGREES')} градусов`;
            break;
        case 'stand_still':
            text = `Стоять на месте`;
            break;
        case 'throw_ai_dice':
            text = `Кинуть AI кубик`;
            break;
        case 'attack':
            text = `Атака на ${block.getFieldValue('DISTANCE')} клеток`;
            break;
        case 'attack_force':
            text = `Атака на ${block.getFieldValue('DISTANCE')} клеток силой ${block.getFieldValue('POWER')}`;
            break;
        case 'defend':
            text = `Защита на ${block.getFieldValue('DISTANCE')}`;
            break;
        case 'freeze':
            text = `Заморозить`;
            break;
        case 'jump':
            text = `Подпрыгнуть`;
            break;

        case 'custom_repeat':
            text = `Повторить ${block.getFieldValue('TIMES')} раз(а)`;
            lines.push(prefix + text);
            const doBlock = block.getInputTargetBlock('DO');
            if (doBlock) {
            traverseStack(doBlock, indent + 1); // ← +1 отступ для тела цикла
            }
            return; // ← не добавляем дальше

        case 'custom_if':
            const conditionBlock = block.getInputTargetBlock('CONDITION');
            let condText = "условие";
            if (conditionBlock) condText = describeCondition(conditionBlock);

            // "Если ... то"
            lines.push(prefix + `Если ${condText}, то`);

            const thenBlock = block.getInputTargetBlock('THEN');
            if (thenBlock) {
            traverseStack(thenBlock, indent + 1); // ← +1 для then
            }

            const elseBlock = block.getInputTargetBlock('ELSE');
            if (elseBlock) {
            lines.push(prefix + "иначе");
            traverseStack(elseBlock, indent + 1); // ← +1 для else
            }
            return; // ← не добавляем дальше

        default:
            text = block.type.replace(/_/g, ' ');
        }

        // Обычные блоки (не if, не repeat)
        lines.push(prefix + text);
    }

    function traverseStack(block, indent = 0) {
        while (block) {
        traverseBlock(block, indent); // ← передаём текущий отступ
        block = block.getNextBlock();
        }
    }

    function describeCondition(block) {
        switch (block.type) {
        case 'enemy_present':
            return `Вижу противника на расстоянии ${block.getFieldValue('DISTANCE')} клеток`;
        case 'obstacle_present':
            return `Препятствие = ${block.getFieldValue('STATE') === 'TRUE' ? 'Да' : 'Нет'}`;
        case 'weather_condition':
            return `Сторона поля = ${block.getFieldValue('CONDITION')}`;
        case 'damage_present':
            return `Есть повреждения бота = ${block.getFieldValue('STATE') === 'TRUE' ? 'Да' : 'Нет'}`;
        case 'water_hit':
            return `Попадание в воду = ${block.getFieldValue('STATE') === 'TRUE' ? 'Да' : 'Нет'}`;
        case 'can_attack':
            return `Можно в Атаку = ${block.getFieldValue('STATE') === 'TRUE' ? 'Да' : 'Нет'}`;
        default:
            return "условие";
        }
    }

    const root = workspace.getTopBlocks(false).find(b => b.type === 'bot_program');
    if (root) {
        lines.push(`=== Программа для Бота: ${root.getFieldValue('PROGRAM_NAME')} ===`);
        const firstLine = root.getInputTargetBlock('PROGRAM_LINES');
        if (firstLine) {
        traverseStack(firstLine, 0); // ← начальный уровень
        // Пройдём по каждой строке программы и её SUBSTACK
        let currentLine = firstLine;
        while (currentLine) {
            const substack = currentLine.getInputTargetBlock('SUBSTACK');
            if (substack) {
            traverseStack(substack, 1); // ← действия внутри строки программы (1 таб)
            }
            currentLine = currentLine.getNextBlock();
        }
        }
    }

    output.textContent = lines.length > 0 ? lines.join('\n') : "// Алгоритм пуст";
    }


window.addEventListener('load', () => {
  workspace = Blockly.inject('blocklyDiv', {
    toolbox: document.getElementById('toolbox'),
    scrollbars: true,
    trashcan: true,
    zoom: { controls: true, wheel: true },
    startScale: 0.8
  });

    // Инициализация позиции
    const initialAlgorithmHeight = 80;
    const defaultAlgorithmHeight = initialAlgorithmHeight;
    algorithmOutput.style.height = initialAlgorithmHeight + 'px';
    algorithmOutput.style.top = `calc(100vh - ${initialAlgorithmHeight + 60}px)`;

    // Ресайз за верхний край
    let isResizing = false;
    algorithmOutput.addEventListener('mousedown', function(e) {
    const rect = algorithmOutput.getBoundingClientRect();
    if (e.clientY >= rect.top && e.clientY <= rect.top + 10) {
        isResizing = true;
        document.body.style.cursor = 'ns-resize';
        e.preventDefault();
    }
    });
    document.addEventListener('mousemove', function(e) {
    if (!isResizing) return;
    const newHeight = window.innerHeight - e.clientY - 60;
    if (newHeight >= 60 && newHeight <= 300) {
        algorithmOutput.style.height = newHeight + 'px';
        algorithmOutput.style.top = `calc(100vh - ${newHeight + 60}px)`;
        onresize();
        saveToStorage();
    }
    });
    document.addEventListener('mouseup', () => {
    isResizing = false;
    document.body.style.cursor = 'default';
    });

  // --- Вспомогательные функции для работы с XML ---
  // В новых версиях Blockly используем Blockly.utils.xml
  const textToDom = function(text) {
    const parser = new DOMParser();
    const xml = parser.parseFromString(text, 'text/xml');
    return xml.documentElement;
  };

  const domToText = function(dom) {
    const serializer = new XMLSerializer();
    return serializer.serializeToString(dom);
  };

  // --- Сохранение в localStorage ---
    const saveToStorage = () => {
    const xml = Blockly.Xml.workspaceToDom(workspace);
    const xmlText = domToText(xml);
    // Получаем текущую высоту зоны алгоритма
    const currentAlgorithmHeight = parseInt(algorithmOutput.style.height, 10) || defaultAlgorithmHeight;
    localStorage.setItem('blocklyWorkspace', JSON.stringify({
        xml: xmlText,
        scale: workspace.scale,
        scrollX: workspace.scrollX,
        scrollY: workspace.scrollY,
        algorithmHeight: currentAlgorithmHeight // Сохраняем высоту
    }));
    };

  // --- Загрузка из localStorage ---
  const loadFromStorage = () => {
    const savedData = localStorage.getItem('blocklyWorkspace');
    if (!savedData) return false;

    try {
      const state = JSON.parse(savedData);
      const xml = textToDom(state.xml);
      workspace.clear();
      Blockly.Xml.domToWorkspace(xml, workspace);

      if (state.scale) workspace.setScale(state.scale);
      if (state.scrollX !== undefined && state.scrollY !== undefined) {
        workspace.scroll(state.scrollX, state.scrollY);
      }

    // --- Загрузка сохранённой высоты зоны алгоритма ---
    if (state.algorithmHeight !== undefined) {
      const loadedHeight = Math.max(60, Math.min(300, state.algorithmHeight)); // Ограничиваем диапазон
      algorithmOutput.style.height = loadedHeight + 'px';
      algorithmOutput.style.top = `calc(100vh - ${loadedHeight + 60}px)`;
    }

      enforceUniqueProgramLines();
      generateReadableAlgorithm();
      return true;
    } catch (e) {
      console.error('Ошибка при загрузке из localStorage:', e);
      return false;
    }
  };

  // --- Обработчик изменений ---
  workspace.addChangeListener((event) => {
    if (event.type === Blockly.Events.UI) return;
    enforceUniqueProgramLines();
    generateReadableAlgorithm();
    saveToStorage();
  });

  // --- Загрузка из localStorage при старте (если есть данные) ---
  const loaded = loadFromStorage();

  // Если ничего не загружено — workspace остаётся пустым
  if (!loaded) {
    // Не создаём дефолтные блоки автоматически
    generateReadableAlgorithm(); // Покажет "Алгоритм пуст"
  }

  // --- Кнопка "Сохранить в файл" (.bot) ---
  document.getElementById('saveButton').onclick = function () {
    const xml = Blockly.Xml.workspaceToDom(workspace);
    const xmlText = domToText(xml);

    const blob = new Blob([xmlText], { type: 'text/xml' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'программа_бота.bot';
    a.click();
    URL.revokeObjectURL(url);

    // Сохраняем и в localStorage
    saveToStorage();
    alert('Программа сохранена в файл "программа_бота.bot"');
  };

  // --- Кнопка "Загрузить из файла" ---
  document.getElementById('loadButton').onclick = function () {
    const input = document.createElement('input');
    input.type = 'file';
    input.accept = '.bot,.xml,.txt';

    input.onchange = function (event) {
      const file = event.target.files[0];
      if (!file) return;

      const reader = new FileReader();
      reader.onload = function (e) {
        const xmlText = e.target.result;
        try {
          const xml = textToDom(xmlText);
          // Проверим, что это действительно XML и есть нужные теги
          if (xml.tagName !== 'xml') {
            throw new Error('Файл не содержит корректный XML для Blockly');
          }

          workspace.clear();
          Blockly.Xml.domToWorkspace(xml, workspace);

          // Сохраняем в localStorage после загрузки
          saveToStorage();
          alert('Программа успешно загружена из файла!');
        } catch (err) {
          alert('Ошибка при загрузке файла: ' + err.message);
          console.error(err);
        }
      };
      reader.readAsText(file);
    };

    input.click();
  };

    // --- Кнопка "Новая программа" --- // <-- Добавьте этот блок
    document.getElementById('newProgramButton').onclick = function () {
    if (workspace.getAllBlocks(false).length > 0 &&
        !confirm('Текущая программа будет заменена. Продолжить?')) {
        return;
    }
    workspace.clear();
    createDefaultBlocks(); 
    saveToStorage();       
    generateReadableAlgorithm(); 

    // --- Сброс высоты зоны алгоритма на стандартную ---
    algorithmOutput.style.height = defaultAlgorithmHeight + 'px';
    algorithmOutput.style.top = `calc(100vh - ${defaultAlgorithmHeight + 60}px)`;
    onresize(); // Пересчитываем размеры BlocklyDiv
    // ----------------------------------------------------

    alert('Создана новая программа по умолчанию.');
    };

  // --- Обработка изменения размера ---
  window.addEventListener('resize', onresize, false);
  onresize();
});

// Экспорт в PDF (с использованием скриншота)
document.getElementById('exportPdfButton').onclick = async function () {
    try {
        // Проверяем загрузку библиотек
        if (typeof pdfMake === 'undefined' || typeof pdfMake.createPdf === 'undefined') {
            throw new Error('Библиотека pdfmake не загружена. Проверьте подключение скриптов.');
        }
        if (typeof html2canvas === 'undefined') {
            throw new Error('Библиотека html2canvas не загружена');
        }
        // --- Получаем текст алгоритма ---
        const algorithmOutputElement = document.getElementById('algorithmOutput');
        const algorithmText = algorithmOutputElement.textContent?.trim() ||
            "// Алгоритм пуст или не сгенерирован.";
        // --- Получаем название программы ---
        let programNameFull = "=== Программа для Бота: Мой Бот ===";

        // --- Сохраняем оригинальные строки с отступами ---
        let algorithmLinesArray = [];
        if (algorithmText) {
            // Разбиваем по символу новой строки, сохраняя отступы
            algorithmLinesArray = algorithmText.split('\n');
            // Проверяем первую строку на заголовок
            if (algorithmLinesArray.length > 0 && algorithmLinesArray[0].startsWith("===")) {
                programNameFull = algorithmLinesArray[0];
                // Убираем первую строку (заголовок) из массива строк алгоритма
                algorithmLinesArray = algorithmLinesArray.slice(1);
            } else {
                // fallback если первая строка не заголовок
                const rootBlock = workspace.getTopBlocks(false).find(b => b.type === 'bot_program');
                const botName = rootBlock ? (rootBlock.getFieldValue('PROGRAM_NAME')?.trim() || "Мой Бот") : "Мой Бот";
                programNameFull = `=== Программа для Бота: ${botName} ===`;
                // Не меняем algorithmLinesArray, так как он уже содержит нужные строки
            }
        }
        // --- Конец получения текста алгоритма ---

        // --- Получаем область Blockly ---
        const blocklyDiv = document.getElementById('blocklyDiv'); // Убедитесь, что ID правильный
        if (!blocklyDiv) {
            throw new Error('Элемент blocklyDiv не найден.');
        }

        // --- Сохраняем текущие стили и обработчики Blockly ---
        const originalBlocklyPointerEvents = blocklyDiv.style.pointerEvents;
        const blocklyWorkspace = Blockly.getMainWorkspace();
        const originalMouseDown = blocklyWorkspace.onMouseDown_;
        const originalMouseMove = blocklyWorkspace.onMouseMove_;
        const originalMouseUp = blocklyWorkspace.onMouseUp_;
        const originalTouchStart = blocklyWorkspace.onTouchStart_; // На случай сенсорных устройств
        const originalTouchMove = blocklyWorkspace.onTouchMove_;
        const originalTouchEnd = blocklyWorkspace.onTouchEnd_;

        // --- Блокируем Blockly: отключаем указательные события и обработчики ---
        blocklyDiv.style.pointerEvents = 'none'; // Блокируем все указательные события (мышь, тач)
        blocklyWorkspace.onMouseDown_ = function() {}; // Блокируем внутренние обработчики Blockly
        blocklyWorkspace.onMouseMove_ = function() {};
        blocklyWorkspace.onMouseUp_ = function() {};
        blocklyWorkspace.onTouchStart_ = function() {};
        blocklyWorkspace.onTouchMove_ = function() {};
        blocklyWorkspace.onTouchEnd_ = function() {};

        // Скрываем blocklyToolbox (по желанию, можно оставить)
        const toolbox = document.getElementsByClassName('blocklyToolbox')[0];
        let toolboxWasVisible = false;
        if (toolbox) {
            toolboxWasVisible = toolbox.style.display !== 'none';
            toolbox.style.display = 'none';
        }

        // Ждем немного чтобы интерфейс обновился (может быть не обязательно)
        // await new Promise(resolve => setTimeout(resolve, 100));

        // --- Создаем оверлей для выбора области ---
        const overlay = document.createElement('div');
        overlay.id = 'selection-overlay';
        overlay.style.cssText = `
            position: fixed;
            border: 2px dashed #007bff;
            background-color: rgba(0, 123, 255, 0.1);
            pointer-events: none; /* Оверлей тоже не должен получать события */
            z-index: 99999;
            display: none;
        `;
        document.body.appendChild(overlay);

        // Создаем инструкцию
        const instruction = document.createElement('div');
        instruction.id = 'selection-instruction';
        instruction.style.cssText = `
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: #007bff;
            color: white;
            padding: 10px 20px;
            border-radius: 5px;
            z-index: 100000;
            font-family: Arial, sans-serif;
            font-size: 14px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.3);
            pointer-events: none; /* Инструкция тоже не должна мешать */
        `;
        instruction.textContent = 'Обведите область с блоками мышью, затем отпустите кнопку';
        document.body.appendChild(instruction);

        // --- Логика выбора области ---
        let isSelecting = false;
        let startX, startY, endX, endY;

        const startSelection = (e) => {
            if (e.button !== 0) return; // Только левая кнопка мыши
            isSelecting = true;
            startX = e.clientX;
            startY = e.clientY;
            overlay.style.display = 'block';
            overlay.style.left = startX + 'px';
            overlay.style.top = startY + 'px';
            overlay.style.width = '0px';
            overlay.style.height = '0px';
            e.preventDefault();
            e.stopPropagation(); // Останавливаем дальнейшее всплытие
        };

        const updateSelection = (e) => {
            if (!isSelecting) return;
            endX = e.clientX;
            endY = e.clientY;
            overlay.style.width = Math.abs(endX - startX) + 'px';
            overlay.style.height = Math.abs(endY - startY) + 'px';
            overlay.style.left = Math.min(startX, endX) + 'px';
            overlay.style.top = Math.min(startY, endY) + 'px';
            e.preventDefault();
            e.stopPropagation(); // Останавливаем дальнейшее всплытие
        };

        const endSelection = async (e) => {
            if (!isSelecting) return;
            isSelecting = false;

            // --- Восстанавливаем Blockly сразу после окончания выделения ---
            // Это важно сделать как можно раньше, чтобы минимизировать блокировку
            blocklyDiv.style.pointerEvents = originalBlocklyPointerEvents; // Восстанавливаем pointer-events
            blocklyWorkspace.onMouseDown_ = originalMouseDown; // Восстанавливаем обработчики
            blocklyWorkspace.onMouseMove_ = originalMouseMove;
            blocklyWorkspace.onMouseUp_ = originalMouseUp;
            blocklyWorkspace.onTouchStart_ = originalTouchStart;
            blocklyWorkspace.onTouchMove_ = originalTouchMove;
            blocklyWorkspace.onTouchEnd_ = originalTouchEnd;
            // ---------------------------------------------------------------

            // --- Удаление элементов интерфейса выбора ---
            const overlayElement = document.getElementById('selection-overlay');
            const instructionElement = document.getElementById('selection-instruction');

            if (overlayElement) {
                overlayElement.remove();
            }
            if (instructionElement) {
                instructionElement.remove();
            }

            const rect = {
                x: Math.min(startX, endX),
                y: Math.min(startY, endY),
                width: Math.abs(endX - startX),
                height: Math.abs(endY - startY)
            };

            // Удаляем элементы интерфейса выбора
            document.removeEventListener('mousedown', startSelection);
            document.removeEventListener('mousemove', updateSelection);
            document.removeEventListener('mouseup', endSelection);
            overlay.remove();
            instruction.remove();

            // Восстанавливаем видимость blocklyToolbox
            if (toolbox && toolboxWasVisible) {
                toolbox.style.display = '';
            }

            // Проверяем, что область выбрана
            if (rect.width < 10 || rect.height < 10) {
                 // Если область слишком мала, всё уже восстановлено, просто выходим
                console.warn('Область слишком мала. Экспорт отменён.');
                alert('Область слишком мала. Попробуйте снова.');
                return; // Выходим из функции
            }

            // --- Делаем скриншот выбранной области ---
        let canvas;
        try {
            // --- АЛЬТЕРНАТИВНЫЙ ПОДХОД: Захватываем прямоугольник на body ---
            // Это может помочь избежать проблем с iframe внутри blocklyDiv
            console.log("Попытка захвата области на document.body:", rect);

            canvas = await html2canvas(document.body, {
                useCORS: true,
                logging: false, // Включаем логирование html2canvas
                scale: 2,
                x: rect.x,
                y: rect.y,
                width: rect.width,
                height: rect.height,
                backgroundColor: "#ffffff",
                // ignoreElements: ... // Не используем, так как захватываем body
            });
            console.log("html2canvas (альтернативный метод) успешно завершена, canvas получен:", canvas);
        } catch (canvasError) {
            console.error("Ошибка внутри html2canvas (альтернативный метод) или при её вызове:", canvasError);
        }

            // Обрезаем белые поля
            canvas = trimCanvas(canvas);
            // Единожды получаем данные изображения
            const imgData = canvas.toDataURL('image/png');
            // --- Формируем документ для pdfmake ---
            const docDefinition = {
                content: [
                    {
                        text: programNameFull,
                        style: 'header',
                        alignment: 'center'
                    },
                    {
                        image: imgData,
                        fit: [500, 700],
                        alignment: 'center',
                        margin: [0, 15, 0, 25]
                    },
                    {
                        text: 'Алгоритм программы:',
                        style: 'subheader'
                    },
                    {
                        stack: algorithmLinesArray.map(line => ({
                            text: line,
                            style: 'algorithm',
                            preserveLeadingSpaces: true
                        })),
                        margin: [0, 5, 0, 0]
                    }
                ],
                styles: {
                    header: {
                        fontSize: 18,
                        bold: true,
                        margin: [0, 0, 0, 10]
                    },
                    subheader: {
                        fontSize: 14,
                        bold: true,
                        margin: [0, 10, 0, 5]
                    },
                    algorithm: {
                        fontSize: 11,
                        lineHeight: 1.3
                    }
                }
            };
            
            // --- Генерируем и скачиваем PDF ---
            let fileName = "Программа для Бота";
            const match = programNameFull.match(/=== Программа для Бота: (.+?) ===/);
            if (match && match[1]) {
                fileName = "Программа для Бота " + match[1].replace(/[^a-zA-Z0-9а-яА-ЯёЁ_\- ]/g, '_');
            } else {
                // fallback если имя не удалось извлечь
                const rootBlock = workspace.getTopBlocks(false).find(b => b.type === 'bot_program');
                const botName = rootBlock ? (rootBlock.getFieldValue('PROGRAM_NAME')?.trim() || "Мой Бот") : "Мой Бот";
                fileName = "Программа для Бота " + botName;
            }
            pdfMake.createPdf(docDefinition).download(fileName + '.pdf');
        }; // Конец endSelection

        // Начинаем процесс выбора области
        document.addEventListener('mousedown', startSelection);
        document.addEventListener('mousemove', updateSelection);
        document.addEventListener('mouseup', endSelection);

        // --- Обработка ошибок и очистка ---
    } catch (error) {
        // В случае ошибки, убедимся, что Blockly разблокирован
        try {
             const blocklyDiv = document.getElementById('blocklyDiv');
             if(blocklyDiv) {
                  blocklyDiv.style.pointerEvents = ''; // Сбрасываем на унаследованное/по умолчанию
             }
             const blocklyWorkspace = Blockly.getMainWorkspace();
             if (blocklyWorkspace) {
                 // Восстанавливаем оригинальные обработчики, если они были сохранены
                 // (Это может быть не идеально, если ошибка произошла до их сохранения)
                 // Лучше было бы сохранять их в замыкании или глобально до блокировки
                 // Но в большинстве случаев это должно помочь
                 if(typeof originalMouseDown !== 'undefined') blocklyWorkspace.onMouseDown_ = originalMouseDown;
                 if(typeof originalMouseMove !== 'undefined') blocklyWorkspace.onMouseMove_ = originalMouseMove;
                 if(typeof originalMouseUp !== 'undefined') blocklyWorkspace.onMouseUp_ = originalMouseUp;
                 if(typeof originalTouchStart !== 'undefined') blocklyWorkspace.onTouchStart_ = originalTouchStart;
                 if(typeof originalTouchMove !== 'undefined') blocklyWorkspace.onTouchMove_ = originalTouchMove;
                 if(typeof originalTouchEnd !== 'undefined') blocklyWorkspace.onTouchEnd_ = originalTouchEnd;
             }
        } catch (restoreError) {
             console.error("Ошибка при восстановлении Blockly:", restoreError);
        }

        // Очищаем вспомогательные элементы интерфейса
        const overlayElement = document.getElementById('selection-overlay');
        const instructionElement = document.getElementById('selection-instruction');
        if (overlayElement) overlayElement.remove();
        if (instructionElement) instructionElement.remove();

        // Удаляем event listeners (на случай, если они остались)
        try {
            document.removeEventListener('mousedown', startSelection);
            document.removeEventListener('mousemove', updateSelection);
            document.removeEventListener('mouseup', endSelection);
        } catch (e) { console.warn("Ошибка при удалении слушателей:", e); }

        // Восстанавливаем видимость blocklyToolbox
        const toolbox = document.getElementsByClassName('blocklyToolbox')[0];
        if (toolbox) {
            toolbox.style.display = '';
        }

        console.error("Ошибка при экспорте:", error);
        alert(`Ошибка экспорта: ${error.message}\nПроверьте консоль браузера для деталей.`);
    }
}; // Конец exportPdfButton.onclick

// --- Вспомогательная функция trimCanvas (убедитесь, что она определена выше или ниже) ---
// Функция для обрезки белых полей с канваса
function trimCanvas(canvas) {
    const ctx = canvas.getContext('2d');
    const width = canvas.width;
    const height = canvas.height;
    const imageData = ctx.getImageData(0, 0, width, height);
    const data = imageData.data;

    let minX = width;
    let minY = height;
    let maxX = -1;
    let maxY = -1;

    for (let y = 0; y < height; y++) {
        for (let x = 0; x < width; x++) {
            const alpha = data[(y * width + x) * 4 + 3];
            if (alpha > 0) { // Если пиксель не полностью прозрачный
                minX = Math.min(minX, x);
                minY = Math.min(minY, y);
                maxX = Math.max(maxX, x);
                maxY = Math.max(maxY, y);
            }
        }
    }

    // Если ничего не найдено, вернуть оригинальный канвас
    if (minX > maxX || minY > maxY) {
         console.warn("trimCanvas: Не удалось найти непрозрачные пиксели. Возвращаю оригинальный канвас.");
         return canvas;
    }

    const trimmedWidth = maxX - minX + 1;
    const trimmedHeight = maxY - minY + 1;

    const trimmedCanvas = document.createElement('canvas');
    trimmedCanvas.width = trimmedWidth;
    trimmedCanvas.height = trimmedHeight;
    const trimmedCtx = trimmedCanvas.getContext('2d');
    trimmedCtx.drawImage(canvas, minX, minY, trimmedWidth, trimmedHeight, 0, 0, trimmedWidth, trimmedHeight);

    return trimmedCanvas;
}


</script>
</body>
</html>