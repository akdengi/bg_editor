<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Редактор программ для Ботов Битвы Големов v0.0.1</title>
  <meta http-equiv="Content-Language" content="ru">
  <meta name="google" content="notranslate">
<style>
  html, body {
    height: 100%;
    margin: 0;
    padding: 0;
    overflow: hidden;
    font-family: Arial, sans-serif;
  }
    #blocklyDiv {
    position: absolute;
    top: 0;
    left: 10px;
    right: 10px;
    height: calc(90% - 80px);
    z-index: 1;
    }
  .button-container {
    position: absolute;
    bottom: 10px;
    left: 10px;
    display: flex;
    gap: 10px;
    z-index: 1000;
  }
  .button-container button {
    padding: 8px 12px;
    background-color: #4CAF50;
    color: white;
    border: none;
    border-radius: 4px;
    cursor: pointer;
    font-size: 14px;
  }
  .button-container button:hover {
    background-color: #45a049;
  }

    #algorithmOutput {
    position: absolute;
    top: calc(90% - 80px); 
    left: 10px;
    right: 10px;
    height: 80px;
    min-height: 60px;
    max-height: 300px;
    overflow-y: auto;
    background-color: #f9f9f9;
    border: 1px solid #ddd;
    border-radius: 4px;
    padding: 10px;
    font-family: 'Courier New', monospace;
    font-size: 14px;
    color: #333;
    white-space: pre;
    line-height: 1.4;
    z-index: 999;
    box-sizing: border-box;
    resize: vertical;
    cursor: ns-resize;
    text-align: left;
    }

    /* Добавляем "ручку" для ресайза сверху */
    #algorithmOutput::before {
    content: "";
    display: block;
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 5px;
    background: #aaa;
    cursor: ns-resize;
    z-index: 1000;
    }

</style>
  <script src="https://unpkg.com/blockly@12.2.0/blockly.min.js"></script>
  <script src="https://unpkg.com/blockly@12.2.0/msg/ru.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdfmake/0.2.12/pdfmake.min.js" integrity="sha512-axXaF5grZBaYl7qiM6OMHgsgVXdSLxqq0w7F4CQxuFyrcPmn0JfnqsOtYHUun80g6mRRdvJDrTCyL8LQqBOt/Q==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdfmake/0.2.12/vfs_fonts.min.js" integrity="sha512-EFlschXPq/G5zunGPRSYqazR1CMKj0cQc8v6eMrQwybxgIbhsfoO5NAMQX3xFDQIbFlViv53o7Hy+yCWw6iZxA==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
  <script src="https://22176.hostkey.in:34172/pictures/bg_editor/html2canvas.min.js"></script>
</head>
<body>
  <div id="blocklyDiv"></div>
  <div class="button-container">
    <button id="saveButton">Сохранить Программу</button>
    <button id="loadButton">Загрузить Программу</button>
    <button id="newProgramButton">Новая программа</button>
    <button id="exportPdfButton">Экспорт в PDF</button>
    <button id="exportPngButton">Экспорт в PNG</button>
  </div>
  <div id="algorithmOutput">// Алгоритм будет здесь...</div>

<xml id="toolbox" style="display: none">
  <category name="Программа" colour="#FF8C00">
    <block type="bot_program"></block>
    <block type="bot_durability"></block>
    <block type="program_line_before"></block>
    <block type="program_line_1"></block>
    <block type="program_line_2"></block>
    <block type="program_line_3"></block>
    <block type="program_line_4"></block>
  </category>
  <category name="Движение" colour="#5599FF">
    <block type="move_forward"></block>
    <block type="move_backward"></block>
    <block type="turn_right"></block>
    <block type="turn_left"></block>
    <block type="stand_still"></block>
    <block type="throw_ai_dice"></block>
  </category>
  <category name="Действия" colour="#FF69B4">
    <block type="attack"></block>
    <block type="attack_force"></block>
    <block type="defend"></block>
    <block type="freeze"></block>
    <block type="jump"></block>
  </category>
  <category name="Циклы и Условия" colour="#FF8C00">
    <block type="custom_repeat"></block>
    <block type="custom_if"></block>
  </category>
  <category name="Условия" colour="#32CD32">
    <block type="enemy_present"></block>
    <block type="obstacle_present"></block>
    <block type="weather_condition"></block>
    <block type="damage_present"></block>
    <block type="water_hit"></block>
    <block type="can_attack"></block>
  </category>
</xml>

<script>
  // --- Перевод контекстного меню ---
  Blockly.Msg["DELETE_BLOCK"] = "Удалить блок";
  Blockly.Msg["DELETE_X_BLOCKS"] = "Удалить %1 блоков";
  Blockly.Msg["DUPLICATE_BLOCK"] = "Дублировать";
  Blockly.Msg["ADD_COMMENT"] = "Добавить комментарий";
  Blockly.Msg["REMOVE_COMMENT"] = "Удалить комментарий";
  Blockly.Msg["INLINE_INPUTS"] = "Встроенные входы";
  Blockly.Msg["EXTERNAL_INPUTS"] = "Внешние входы";
  Blockly.Msg["COLLAPSE_BLOCK"] = "Свернуть блок";
  Blockly.Msg["EXPAND_BLOCK"] = "Развернуть блок";
  Blockly.Msg["DISABLE_BLOCK"] = "Отключить блок";
  Blockly.Msg["ENABLE_BLOCK"] = "Включить блок";
  Blockly.Msg["HELP"] = "Помощь";

  // --- Определение блоков ---
  Blockly.defineBlocksWithJsonArray([
    {
      "type": "bot_program",
      "message0": "=== Программа для Бота: %1 ===",
      "args0": [{ "type": "field_input", "name": "PROGRAM_NAME", "text": "Имя Бота" }],
      "message1": "%1",
      "args1": [{ "type": "input_statement", "name": "PROGRAM_LINES", "check": "ProgramLine" }],
      "colour": "#FF8C00",
      "tooltip": "Начальный блок программы бота.",
      "previousStatement": null,
      "nextStatement": null
    },
    {
      "type": "bot_durability",
      "message0": "Прочность Бота %1 единиц Атаки",
      "args0": [{ "type": "field_dropdown", "name": "DURABILITY", "options": [["1", "1"], ["2", "2"], ["3", "3"], ["4", "4"]] }],
      "previousStatement": "ProgramLine", 
      "nextStatement": "ProgramLine",
      "colour": "#32CD32",
      "tooltip": "Устанавливает прочность бота (количество единиц атаки, которые он может выдержать).",
      "helpUrl": ""
    },
    {
      "type": "program_line_before",
      "message0": "Программа исполняется в начале раунда",
      "message1": "%1",
      "args1": [{ "type": "input_statement", "name": "SUBSTACK", "check": "Action" }],
      "previousStatement": "ProgramLine",
      "nextStatement": "ProgramLine",
      "colour": "#FF8C00"
    },
    {
      "type": "program_line_1",
      "message0": "Перед строкой Программы 1",
      "message1": "%1",
      "args1": [{ "type": "input_statement", "name": "SUBSTACK", "check": "Action" }],
      "previousStatement": "ProgramLine",
      "nextStatement": "ProgramLine",
      "colour": "#FF8C00"
    },
    {
      "type": "program_line_2",
      "message0": "Перед строкой Программы 2",
      "message1": "%1",
      "args1": [{ "type": "input_statement", "name": "SUBSTACK", "check": "Action" }],
      "previousStatement": "ProgramLine",
      "nextStatement": "ProgramLine",
      "colour": "#FF8C00"
    },
    {
      "type": "program_line_3",
      "message0": "Перед строкой Программы 3",
      "message1": "%1",
      "args1": [{ "type": "input_statement", "name": "SUBSTACK", "check": "Action" }],
      "previousStatement": "ProgramLine",
      "nextStatement": "ProgramLine",
      "colour": "#FF8C00"
    },
    {
      "type": "program_line_4",
      "message0": "Перед строкой Программы 4",
      "message1": "%1",
      "args1": [{ "type": "input_statement", "name": "SUBSTACK", "check": "Action" }],
      "previousStatement": "ProgramLine",
      "nextStatement": "ProgramLine",
      "colour": "#FF8C00"
    },
    {
      "type": "move_forward",
      "message0": "Идти %1 шагов",
      "args0": [{ "type": "field_dropdown", "name": "STEPS", "options": [["1", "1"], ["2", "2"], ["3", "3"], ["4", "4"]] }],
      "previousStatement": "Action",
      "nextStatement": "Action",
      "colour": "#5599FF"
    },
    {
      "type": "move_backward",
      "message0": "Идти -%1 шагов",
      "args0": [{ "type": "field_dropdown", "name": "STEPS", "options": [["1", "1"], ["2", "2"], ["3", "3"], ["4", "4"]] }],
      "previousStatement": "Action",
      "nextStatement": "Action",
      "colour": "#5599FF"
    },
    {
      "type": "turn_right",
      "message0": "Повернуть ↻ на %1 градусов",
      "args0": [{ "type": "field_dropdown", "name": "DEGREES", "options": [["90", "90"], ["180", "180"]] }],
      "previousStatement": "Action",
      "nextStatement": "Action",
      "colour": "#5599FF"
    },
    {
      "type": "turn_left",
      "message0": "Повернуть ↺ на %1 градусов",
      "args0": [{ "type": "field_dropdown", "name": "DEGREES", "options": [["90", "90"], ["180", "180"]] }],
      "previousStatement": "Action",
      "nextStatement": "Action",
      "colour": "#5599FF"
    },
    {
      "type": "stand_still",
      "message0": "Ждать до <следующая команда>",
      "previousStatement": "Action",
      "nextStatement": "Action",
      "colour": "#5599FF"
    },
    {
      "type": "attack",
      "message0": "Атака на %1",
      "args0": [{ "type": "field_dropdown", "name": "DISTANCE", "options": [["1","1"],["2","2"],["3","3"]] }],
      "previousStatement": "Action",
      "nextStatement": "Action",
      "colour": "#FF69B4"
    },
    {
      "type": "attack_force",
      "message0": "Атака на %1 силой %2",
      "args0": [
        { "type": "field_dropdown", "name": "DISTANCE", "options": [["1","1"],["2","2"],["3","3"]] },
        { "type": "field_dropdown", "name": "POWER", "options": [["1","1"],["2","2"]] }
      ],
      "previousStatement": "Action",
      "nextStatement": "Action",
      "colour": "#FF69B4"
    },
    {
      "type": "defend",
      "message0": "Защита на %1",
      "args0": [{ "type": "field_dropdown", "name": "DISTANCE", "options": [["1","1"],["2","2"],["3","3"]] }],
      "previousStatement": "Action",
      "nextStatement": "Action",
      "colour": "#FF69B4"
    },
    {
      "type": "freeze",
      "message0": "Заморозить",
      "previousStatement": "Action",
      "nextStatement": "Action",
      "colour": "#FF69B4"
    },
    {
      "type": "jump",
      "message0": "Подпрыгнуть",
      "previousStatement": "Action",
      "nextStatement": "Action",
      "colour": "#FF69B4"
    },
    {
      "type": "throw_ai_dice",
      "message0": "Кинь AI кубик",
      "previousStatement": "Action",
      "nextStatement": "Action",
      "colour": "#5599FF"
    },
    {
      "type": "enemy_present",
      "message0": "Вижу противника на расстоянии %1",
      "args0": [{ "type": "field_dropdown", "name": "DISTANCE", "options": [["1", "1"], ["2", "2"], ["3", "3"], ["4", "4"]] }],
      "output": "Boolean",
      "colour": "#32CD32"
    },
    {
      "type": "obstacle_present",
      "message0": "Препятствие = %1",
      "args0": [{ "type": "field_dropdown", "name": "STATE", "options": [["0","FALSE"],["1","TRUE"]] }],
      "output": "Boolean",
      "colour": "#32CD32"
    },
    {
      "type": "weather_condition",
      "message0": "Сторона поля = %1",
      "args0": [{ "type": "field_dropdown", "name": "CONDITION", "options": [["Лето","SUMMER"],["Зима","WINTER"]] }],
      "output": "Boolean",
      "colour": "#32CD32"
    },
    {
      "type": "damage_present",
      "message0": "Есть повреждения бота = %1",
      "args0": [{ "type": "field_dropdown", "name": "STATE", "options": [["0","FALSE"],["1","TRUE"]] }],
      "output": "Boolean",
      "colour": "#32CD32"
    },
    {
      "type": "water_hit",
      "message0": "Попадание в воду = %1",
      "args0": [{ "type": "field_dropdown", "name": "STATE", "options": [["0","FALSE"],["1","TRUE"]] }],
      "output": "Boolean",
      "colour": "#32CD32"
    },
    {
      "type": "can_attack",
      "message0": "Можно в Атаку = %1",
      "args0": [{ "type": "field_dropdown", "name": "STATE", "options": [["0", "FALSE"],["1", "TRUE"]]}],
      "output": "Boolean",
      "colour": "#32CD32"
    },
    {
      "type": "custom_repeat",
      "message0": "Повторить %1 раз(а)",
      "args0": [{ "type": "field_number", "name": "TIMES", "value": 1, "min": 1, "max": 10 }],
      "message1": "%1",
      "args1": [{ "type": "input_statement", "name": "DO", "check": "Action" }],
      "previousStatement": "Action",
      "nextStatement": "Action",
      "colour": "#FF8C00"
    },
    {
      "type": "custom_if",
      "message0": "если %1 то %2",
      "args0": [
        { "type": "input_value", "name": "CONDITION", "check": "Boolean" },
        { "type": "input_statement", "name": "THEN", "check": "Action" }
      ],
      "message1": "иначе %1",
      "args1": [{ "type": "input_statement", "name": "ELSE", "check": "Action" }],
      "previousStatement": "Action",
      "nextStatement": "Action",
      "colour": "#FF8C00"
    }
  ]);

    let workspace = null;
    const onresize = () => {
    const blocklyDiv = document.getElementById('blocklyDiv');
    const algorithmOutput = document.getElementById('algorithmOutput');
    const buttonAreaHeight = 60;
    const outputHeight = algorithmOutput.offsetHeight; // <- Использует текущую высоту
    const outputTop = algorithmOutput.offsetTop;       // <- Использует текущую позицию
    // Высота blocklyDiv = от верха до верха зоны алгоритма
    blocklyDiv.style.height = outputTop + 'px'; // <- Устанавливает высоту BlocklyDiv
    Blockly.svgResize(workspace);
    };

  // --- Функция для создания дефолтных блоков ---
  function createDefaultBlocks() {
    const rootBlock = workspace.newBlock('bot_program');
    rootBlock.getField('PROGRAM_NAME').setValue('Мой Бот');
    rootBlock.initSvg();
    rootBlock.render();

    // Создаём блок прочности
    const durabilityBlock = workspace.newBlock('bot_durability');
    durabilityBlock.initSvg();
    durabilityBlock.render();

    // Создаём первый блок строки программы
    const line1 = workspace.newBlock('program_line_before');
    line1.initSvg();
    line1.render();

    // Соединяем блоки:
    // 1. Блок прочности подключаем к основному блоку программы (к его nextStatement)
    rootBlock.nextConnection.connect(durabilityBlock.previousConnection);

    // 2. Блок строки программы подключаем к блоку прочности
    durabilityBlock.nextConnection.connect(line1.previousConnection);

    // Позиционируем корневой блок (остальные последуют за ним)
    rootBlock.moveBy(50, 50);
  }

  // --- Ограничение: только один экземпляр каждого program_line_* блока ---
  function enforceUniqueProgramLines() {
    const allowedTypes = ['program_line_before', 'program_line_1', 'program_line_2', 'program_line_3', 'program_line_4'];
    const usedTypes = new Set();

    const allBlocks = workspace.getAllBlocks(false);
    for (const block of allBlocks) {
      if (allowedTypes.includes(block.type)) {
        if (usedTypes.has(block.type)) {
          block.dispose(); // Удаляем дубликат
        } else {
          usedTypes.add(block.type);
        }
      }
    }
  }

  // --- Генератор JavaScript ---
  const javascriptGenerator = Blockly.JavaScript;

  // Генераторы (остаются без изменений)
  javascriptGenerator['bot_program'] = function(block) {
    const programName = block.getFieldValue('PROGRAM_NAME');
    const substack = javascriptGenerator.statementToCode(block, 'PROGRAM_LINES') || '';
    return `// === Программа Бота: ${programName} ===\n${substack}`;
  };

    javascriptGenerator['bot_durability'] = function(block) {
    const durability = block.getFieldValue('DURABILITY');
    // Предполагаем, что в скриптах бота будет функция setDurability
    return `setDurability(${durability});`;
  };

  ['program_line_before', 'program_line_1', 'program_line_2', 'program_line_3', 'program_line_4'].forEach((type, i) => {
    javascriptGenerator[type] = function(block) {
      const substack = javascriptGenerator.statementToCode(block, 'SUBSTACK') || '';
      return `// --- Строка Программы ${i+1} ---\n${substack}`;
    };
  });

  // Остальные генераторы (не меняем)
  javascriptGenerator['move_forward'] = (block) => `moveForward(${block.getFieldValue('STEPS')});\n`;
  javascriptGenerator['move_backward'] = (block) => `moveBackward(${block.getFieldValue('STEPS')});\n`;
  javascriptGenerator['turn_right'] = (block) => `turnRight(${block.getFieldValue('DEGREES')});\n`;
  javascriptGenerator['turn_left'] = (block) => `turnLeft(${block.getFieldValue('DEGREES')});\n`;
  javascriptGenerator['stand_still'] = () => `standStill();\n`;
  javascriptGenerator['attack'] = (block) => `attack(${block.getFieldValue('DISTANCE')});\n`;
  javascriptGenerator['attack_force'] = (block) => `attack(${block.getFieldValue('DISTANCE')}, ${block.getFieldValue('POWER')});\n`;
  javascriptGenerator['defend'] = (block) => `defend(${block.getFieldValue('DISTANCE')});\n`;
  javascriptGenerator['freeze'] = () => `freeze();\n`;
  javascriptGenerator['jump'] = () => `jump();\n`;
  javascriptGenerator['throw_ai_dice'] = () => `throwAIDice();\n`;
  javascriptGenerator['custom_repeat'] = function(block) {
    const times = block.getFieldValue('TIMES');
    const doBlock = javascriptGenerator.statementToCode(block, 'DO') || '';
    return `repeat(${times}, function() {\n  ${doBlock}});\n`;
  };
  javascriptGenerator['custom_if'] = function(block) {
    const condition = javascriptGenerator.valueToCode(block, 'CONDITION', javascriptGenerator.ORDER_NONE) || 'false';
    const thenCode = javascriptGenerator.statementToCode(block, 'THEN') || '';
    const elseCode = javascriptGenerator.statementToCode(block, 'ELSE') || '';
    return `if (${condition}) {\n  ${thenCode}} else {\n  ${elseCode}\n}\n`;
  };

  // --- Генерация читаемого алгоритма ---
    function generateReadableAlgorithm() {
    const output = document.getElementById('algorithmOutput');
    const lines = [];

    function traverseBlock(block, indent = 0) {
        if (!block) return;
        const prefix = "  ".repeat(indent); // ← Теперь табуляция (Python style)
        let text = "";

        switch (block.type) {
        case 'bot_durability':
            text = `Прочность Бота ${block.getFieldValue('DURABILITY')} единиц Атаки`;
            break;
        case 'program_line_before':
            text = 'Программа исполняется в начале раунда';
            break;
        case 'program_line_1':
            text = 'Перед строкой Программы 1';
            break;
        case 'program_line_2':
            text = 'Перед строкой Программы 2';
            break;
        case 'program_line_3':
            text = 'Перед строкой Программы 3';
            break;
        case 'program_line_4':
            text = 'Перед строкой Программы 4';
            break;
        case 'move_forward':
            text = `Вперед на ${block.getFieldValue('STEPS')} шагов`;
            break;
        case 'move_backward':
            text = `Назад на ${block.getFieldValue('STEPS')} шагов`;
            break;
        case 'turn_right':
            text = `Поворот Вправо на ${block.getFieldValue('DEGREES')} градусов`;
            break;
        case 'turn_left':
            text = `Поворот Влево на ${block.getFieldValue('DEGREES')} градусов`;
            break;
        case 'stand_still':
            text = `Стоять на месте`;
            break;
        case 'throw_ai_dice':
            text = `Кинуть AI кубик`;
            break;
        case 'attack':
            text = `Атака на ${block.getFieldValue('DISTANCE')} клеток`;
            break;
        case 'attack_force':
            text = `Атака на ${block.getFieldValue('DISTANCE')} клеток силой ${block.getFieldValue('POWER')}`;
            break;
        case 'defend':
            text = `Защита на ${block.getFieldValue('DISTANCE')}`;
            break;
        case 'freeze':
            text = `Заморозить`;
            break;
        case 'jump':
            text = `Подпрыгнуть`;
            break;

        case 'custom_repeat':
            text = `Повторить ${block.getFieldValue('TIMES')} раз(а)`;
            lines.push(prefix + text);
            const doBlock = block.getInputTargetBlock('DO');
            if (doBlock) {
            traverseStack(doBlock, indent + 1); // ← +1 отступ для тела цикла
            }
            return; // ← не добавляем дальше

        case 'custom_if':
            const conditionBlock = block.getInputTargetBlock('CONDITION');
            let condText = "условие";
            if (conditionBlock) condText = describeCondition(conditionBlock);

            // "Если ... то"
            lines.push(prefix + `Если ${condText}, то`);

            const thenBlock = block.getInputTargetBlock('THEN');
            if (thenBlock) {
            traverseStack(thenBlock, indent + 1); // ← +1 для then
            }

            const elseBlock = block.getInputTargetBlock('ELSE');
            if (elseBlock) {
            lines.push(prefix + "иначе");
            traverseStack(elseBlock, indent + 1); // ← +1 для else
            }
            return; // ← не добавляем дальше

        default:
            text = block.type.replace(/_/g, ' ');
        }

        // Обычные блоки (не if, не repeat)
        lines.push(prefix + text);
    }

    function traverseStack(block, indent = 0) {
        while (block) {
        traverseBlock(block, indent); // ← передаём текущий отступ
        block = block.getNextBlock();
        }
    }

    function describeCondition(block) {
        switch (block.type) {
        case 'enemy_present':
            return `Вижу противника на расстоянии ${block.getFieldValue('DISTANCE')} клеток`;
        case 'obstacle_present':
            return `Препятствие = ${block.getFieldValue('STATE') === 'TRUE' ? 'Да' : 'Нет'}`;
        case 'weather_condition':
            return `Сторона поля = ${block.getFieldValue('CONDITION')}`;
        case 'damage_present':
            return `Есть повреждения бота = ${block.getFieldValue('STATE') === 'TRUE' ? 'Да' : 'Нет'}`;
        case 'water_hit':
            return `Попадание в воду = ${block.getFieldValue('STATE') === 'TRUE' ? 'Да' : 'Нет'}`;
        case 'can_attack':
            return `Можно в Атаку = ${block.getFieldValue('STATE') === 'TRUE' ? 'Да' : 'Нет'}`;
        default:
            return "условие";
        }
    }

    const root = workspace.getTopBlocks(false).find(b => b.type === 'bot_program');
            let durabilityLine = "";

    if (root) {
        lines.push(`=== Программа для Бота: ${root.getFieldValue('PROGRAM_NAME')} ===`);

        // --- Новый способ поиска и обработки bot_durability ---
        // Ищем следующий блок после bot_program, который может быть bot_durability
        const nextBlock = root.getNextBlock(); // Получаем блок, подключенный к nextStatement

        if (nextBlock && nextBlock.type === 'bot_durability') {
            // Если следующий блок - это блок прочности, получаем значение
            const durabilityValue = nextBlock.getFieldValue('DURABILITY');
            durabilityLine = `Прочность Бота ${durabilityValue} единиц Атаки`;
        }
        lines.push(durabilityLine); // Добавляем строку о прочности

        // Обрабатываем строки программы (PROGRAM_LINES)
        const firstLine = root.getInputTargetBlock('PROGRAM_LINES');
        if (firstLine) {
            let currentLine = firstLine;
            while (currentLine) {
                traverseBlock(currentLine, 0);
                const substack = currentLine.getInputTargetBlock('SUBSTACK');
                if (substack) {
                    traverseStack(substack, 1);
                }
                currentLine = currentLine.getNextBlock();
            }
        }
    }


    output.textContent = lines.length > 0 ? lines.join('\n') : "// Алгоритм пуст";
    }


window.addEventListener('load', () => {
  workspace = Blockly.inject('blocklyDiv', {
    toolbox: document.getElementById('toolbox'),
    scrollbars: true,
    trashcan: true,
    zoom: { controls: true, wheel: true },
    startScale: 0.8
  });

    // Инициализация позиции
    const initialAlgorithmHeight = 80;
    const defaultAlgorithmHeight = initialAlgorithmHeight;
    algorithmOutput.style.height = initialAlgorithmHeight + 'px';
    algorithmOutput.style.top = `calc(100vh - ${initialAlgorithmHeight + 60}px)`;

    // Ресайз за верхний край
    let isResizing = false;
    algorithmOutput.addEventListener('mousedown', function(e) {
    const rect = algorithmOutput.getBoundingClientRect();
    if (e.clientY >= rect.top && e.clientY <= rect.top + 10) {
        isResizing = true;
        document.body.style.cursor = 'ns-resize';
        e.preventDefault();
    }
    });
    document.addEventListener('mousemove', function(e) {
    if (!isResizing) return;
    const newHeight = window.innerHeight - e.clientY - 60;
    if (newHeight >= 60 && newHeight <= 300) {
        algorithmOutput.style.height = newHeight + 'px';
        algorithmOutput.style.top = `calc(100vh - ${newHeight + 60}px)`;
        onresize();
        saveToStorage();
    }
    });
    document.addEventListener('mouseup', () => {
    isResizing = false;
    document.body.style.cursor = 'default';
    });

  // --- Вспомогательные функции для работы с XML ---
  // В новых версиях Blockly используем Blockly.utils.xml
  const textToDom = function(text) {
    const parser = new DOMParser();
    const xml = parser.parseFromString(text, 'text/xml');
    return xml.documentElement;
  };

  const domToText = function(dom) {
    const serializer = new XMLSerializer();
    return serializer.serializeToString(dom);
  };

  // --- Сохранение в localStorage ---
    const saveToStorage = () => {
    const xml = Blockly.Xml.workspaceToDom(workspace);
    const xmlText = domToText(xml);
    // Получаем текущую высоту зоны алгоритма
    const currentAlgorithmHeight = parseInt(algorithmOutput.style.height, 10) || defaultAlgorithmHeight;
    localStorage.setItem('blocklyWorkspace', JSON.stringify({
        xml: xmlText,
        scale: workspace.scale,
        scrollX: workspace.scrollX,
        scrollY: workspace.scrollY,
        algorithmHeight: currentAlgorithmHeight // Сохраняем высоту
    }));
    };

  // --- Загрузка из localStorage ---
  const loadFromStorage = () => {
    const savedData = localStorage.getItem('blocklyWorkspace');
    if (!savedData) return false;

    try {
      const state = JSON.parse(savedData);
      const xml = textToDom(state.xml);
      workspace.clear();
      Blockly.Xml.domToWorkspace(xml, workspace);

      if (state.scale) workspace.setScale(state.scale);
      if (state.scrollX !== undefined && state.scrollY !== undefined) {
        workspace.scroll(state.scrollX, state.scrollY);
      }

    // --- Загрузка сохранённой высоты зоны алгоритма ---
    if (state.algorithmHeight !== undefined) {
      const loadedHeight = Math.max(60, Math.min(300, state.algorithmHeight)); // Ограничиваем диапазон
      algorithmOutput.style.height = loadedHeight + 'px';
      algorithmOutput.style.top = `calc(100vh - ${loadedHeight + 60}px)`;
    }

      enforceUniqueProgramLines();
      generateReadableAlgorithm();
      return true;
    } catch (e) {
      console.error('Ошибка при загрузке из localStorage:', e);
      return false;
    }
  };

  // --- Обработчик изменений ---
  workspace.addChangeListener((event) => {
    if (event.type === Blockly.Events.UI) return;
    enforceUniqueProgramLines();
    generateReadableAlgorithm();
    saveToStorage();
  });

  // --- Загрузка из localStorage при старте (если есть данные) ---
  const loaded = loadFromStorage();

  // Если ничего не загружено — workspace остаётся пустым
  if (!loaded) {
    // Не создаём дефолтные блоки автоматически
    generateReadableAlgorithm(); // Покажет "Алгоритм пуст"
  }

  // --- Кнопка "Сохранить в файл" (.bot) ---
  document.getElementById('saveButton').onclick = function () {
    const xml = Blockly.Xml.workspaceToDom(workspace);
    const xmlText = domToText(xml);

    // --- Получение имени бота из корневого блока ---
    let fileNameBase = "Программа для бота"; // Значение по умолчанию
    const rootBlock = workspace.getTopBlocks(false).find(b => b.type === 'bot_program');
    if (rootBlock) {
      const botName = rootBlock.getFieldValue('PROGRAM_NAME')?.trim();
      if (botName) {
        // Заменяем недопустимые символы для имени файла
        fileNameBase = `Программа для бота ${botName}`.replace(/[/\\?%*:|"<>]/g, '_');
      }
    }
    const fileName = `${fileNameBase}.bot`;
    // ---------------------------------------------

    const blob = new Blob([xmlText], { type: 'text/xml' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = fileName; // Используем динамическое имя файла
    a.click();
    URL.revokeObjectURL(url);
    // Сохраняем и в localStorage
    saveToStorage();
    // Обновляем сообщение об успешном сохранении с новым именем файла
    alert(`Программа сохранена в файл "${fileName}"`); 
  };

  // --- Кнопка "Загрузить из файла" ---
  document.getElementById('loadButton').onclick = function () {
    const input = document.createElement('input');
    input.type = 'file';
    input.accept = '.bot,.xml,.txt';

    input.onchange = function (event) {
      const file = event.target.files[0];
      if (!file) return;

      const reader = new FileReader();
      reader.onload = function (e) {
        const xmlText = e.target.result;
        try {
          const xml = textToDom(xmlText);
          // Проверим, что это действительно XML и есть нужные теги
          if (xml.tagName !== 'xml') {
            throw new Error('Файл не содержит корректный XML для Blockly');
          }

          workspace.clear();
          Blockly.Xml.domToWorkspace(xml, workspace);

          // Сохраняем в localStorage после загрузки
          saveToStorage();
          alert('Программа успешно загружена из файла!');
        } catch (err) {
          alert('Ошибка при загрузке файла: ' + err.message);
          console.error(err);
        }
      };
      reader.readAsText(file);
    };

    input.click();
  };

    // --- Кнопка "Новая программа" --- // <-- Добавьте этот блок
    document.getElementById('newProgramButton').onclick = function () {
    if (workspace.getAllBlocks(false).length > 0 &&
        !confirm('Текущая программа будет заменена. Продолжить?')) {
        return;
    }
    workspace.clear();
    createDefaultBlocks(); 
    saveToStorage();       
    generateReadableAlgorithm(); 

    // --- Сброс высоты зоны алгоритма на стандартную ---
    algorithmOutput.style.height = defaultAlgorithmHeight + 'px';
    algorithmOutput.style.top = `calc(100vh - ${defaultAlgorithmHeight + 60}px)`;
    onresize(); // Пересчитываем размеры BlocklyDiv
    // ----------------------------------------------------

    alert('Создана новая программа по умолчанию.');
    };

  // --- Обработка изменения размера ---
  window.addEventListener('resize', onresize, false);
  onresize();
});

// --- Общая функция для выделения области и получения скриншота ---
// Определяем её в глобальной области видимости
async function selectAreaAndCapture() {
    return new Promise((resolve, reject) => {
        // --- Получаем область Blockly ---
        const blocklyDiv = document.getElementById('blocklyDiv');
        if (!blocklyDiv) {
            reject(new Error('Элемент blocklyDiv не найден.'));
            return;
        }

        // --- Сохраняем текущие стили и обработчики Blockly ---
        const originalBlocklyPointerEvents = blocklyDiv.style.pointerEvents;
        const blocklyWorkspace = Blockly.getMainWorkspace();
        const originalMouseDown = blocklyWorkspace.onMouseDown_;
        const originalMouseMove = blocklyWorkspace.onMouseMove_;
        const originalMouseUp = blocklyWorkspace.onMouseUp_;
        const originalTouchStart = blocklyWorkspace.onTouchStart_;
        const originalTouchMove = blocklyWorkspace.onTouchMove_;
        const originalTouchEnd = blocklyWorkspace.onTouchEnd_;

        // --- Блокируем Blockly: отключаем указательные события и обработчики ---
        blocklyDiv.style.pointerEvents = 'none';
        blocklyWorkspace.onMouseDown_ = function() {};
        blocklyWorkspace.onMouseMove_ = function() {};
        blocklyWorkspace.onMouseUp_ = function() {};
        blocklyWorkspace.onTouchStart_ = function() {};
        blocklyWorkspace.onTouchMove_ = function() {};
        blocklyWorkspace.onTouchEnd_ = function() {};

        // Скрываем blocklyToolbox (по желанию)
        const toolbox = document.getElementsByClassName('blocklyToolbox')[0];
        let toolboxWasVisible = false;
        if (toolbox) {
            toolboxWasVisible = toolbox.style.display !== 'none';
            toolbox.style.display = 'none';
        }

        // --- Создаем оверлей для выбора области ---
        const overlay = document.createElement('div');
        overlay.id = 'selection-overlay';
        overlay.style.cssText = `
            position: fixed;
            border: 2px dashed #007bff;
            background-color: rgba(0, 123, 255, 0.1);
            pointer-events: none;
            z-index: 99999;
            display: none;
        `;
        document.body.appendChild(overlay);

        // Создаем инструкцию
        const instruction = document.createElement('div');
        instruction.id = 'selection-instruction';
        instruction.style.cssText = `
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: #007bff;
            color: white;
            padding: 10px 20px;
            border-radius: 5px;
            z-index: 100000;
            font-family: Arial, sans-serif;
            font-size: 14px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.3);
            pointer-events: none;
        `;
        instruction.textContent = 'Обведите область с блоками мышью, затем отпустите кнопку';
        document.body.appendChild(instruction);

        // --- Логика выбора области ---
        let isSelecting = false;
        let startX, startY, endX, endY;

        const startSelection = (e) => {
            if (e.button !== 0) return; // Только левая кнопка мыши
            isSelecting = true;
            startX = e.clientX;
            startY = e.clientY;
            overlay.style.display = 'block';
            overlay.style.left = startX + 'px';
            overlay.style.top = startY + 'px';
            overlay.style.width = '0px';
            overlay.style.height = '0px';
            e.preventDefault();
            e.stopPropagation();
        };

        const updateSelection = (e) => {
            if (!isSelecting) return;
            endX = e.clientX;
            endY = e.clientY;
            overlay.style.width = Math.abs(endX - startX) + 'px';
            overlay.style.height = Math.abs(endY - startY) + 'px';
            overlay.style.left = Math.min(startX, endX) + 'px';
            overlay.style.top = Math.min(startY, endY) + 'px';
            e.preventDefault();
            e.stopPropagation();
        };

        const endSelection = async (e) => {
            if (!isSelecting) return;
            isSelecting = false;

            // --- Восстанавливаем Blockly сразу после окончания выделения ---
            blocklyDiv.style.pointerEvents = originalBlocklyPointerEvents;
            blocklyWorkspace.onMouseDown_ = originalMouseDown;
            blocklyWorkspace.onMouseMove_ = originalMouseMove;
            blocklyWorkspace.onMouseUp_ = originalMouseUp;
            blocklyWorkspace.onTouchStart_ = originalTouchStart;
            blocklyWorkspace.onTouchMove_ = originalTouchMove;
            blocklyWorkspace.onTouchEnd_ = originalTouchEnd;

            // --- Удаление элементов интерфейса выбора ---
            const overlayElement = document.getElementById('selection-overlay');
            const instructionElement = document.getElementById('selection-instruction');
            if (overlayElement) overlayElement.remove();
            if (instructionElement) instructionElement.remove();

            const rect = {
                x: Math.min(startX, endX),
                y: Math.min(startY, endY),
                width: Math.abs(endX - startX),
                height: Math.abs(endY - startY)
            };

            document.removeEventListener('mousedown', startSelection);
            document.removeEventListener('mousemove', updateSelection);
            document.removeEventListener('mouseup', endSelection);

            // Восстанавливаем видимость blocklyToolbox
            if (toolbox && toolboxWasVisible) {
                toolbox.style.display = '';
            }

            // Проверяем, что область выбрана
            if (rect.width < 10 || rect.height < 10) {
                console.warn('Область слишком мала. Экспорт отменён.');
                alert('Область слишком мала. Попробуйте снова.');
                reject(new Error('Область слишком мала.'));
                return;
            }

            try {
                // --- Делаем скриншот выбранной области ---
                console.log("Попытка захвата области на document.body:", rect);
                let canvas = await html2canvas(document.body, {
                    useCORS: true,
                    logging: false,
                    scale: 2, // Можно настроить качество
                    x: rect.x,
                    y: rect.y,
                    width: rect.width,
                    height: rect.height,
                    backgroundColor: "#ffffff",
                });
                console.log("html2canvas успешно завершена, canvas получен:", canvas);

                // Обрезаем белые поля
                canvas = trimCanvas(canvas);

                resolve(canvas); // Возвращаем канвас через Promise

            } catch (canvasError) {
                console.error("Ошибка внутри html2canvas или при её вызове:", canvasError);
                reject(canvasError);
            }
        }; // Конец endSelection

        // Начинаем процесс выбора области
        document.addEventListener('mousedown', startSelection);
        document.addEventListener('mousemove', updateSelection);
        document.addEventListener('mouseup', endSelection);
    });
}

// --- Экспорт в PDF (использует общую функцию выделения) ---
document.getElementById('exportPdfButton').onclick = async function () {
    try {
        if (typeof pdfMake === 'undefined' || typeof pdfMake.createPdf === 'undefined') {
            throw new Error('Библиотека pdfmake не загружена. Проверьте подключение скриптов.');
        }
        if (typeof html2canvas === 'undefined') {
            throw new Error('Библиотека html2canvas не загружена');
        }

        // --- Получаем текст алгоритма ---
        const algorithmOutputElement = document.getElementById('algorithmOutput');
        const algorithmText = algorithmOutputElement.textContent?.trim() || "// Алгоритм пуст или не сгенерирован.";

        // --- Получаем название программы ---
        let programNameFull = "=== Программа для Бота: Мой Бот ===";
        let algorithmLinesArray = [];
        if (algorithmText) {
            algorithmLinesArray = algorithmText.split('\n');
            if (algorithmLinesArray.length > 0 && algorithmLinesArray[0].startsWith("===")) {
                programNameFull = algorithmLinesArray[0];
                algorithmLinesArray = algorithmLinesArray.slice(1);
            } else {
                const rootBlock = workspace.getTopBlocks(false).find(b => b.type === 'bot_program');
                const botName = rootBlock ? (rootBlock.getFieldValue('PROGRAM_NAME')?.trim() || "Мой Бот") : "Мой Бот";
                programNameFull = `=== Программа для Бота: ${botName} ===`;
            }
        }

        // --- Вызываем общую функцию выделения ---
        const canvas = await selectAreaAndCapture(); // <-- Используем общую функцию

        const imgData = canvas.toDataURL('image/png');

        // --- Формируем документ для pdfmake ---
        const docDefinition = {
            content: [
                { text: programNameFull, style: 'header', alignment: 'center' },
                {
                    image: imgData,
                    fit: [500, 700],
                    alignment: 'center',
                    margin: [0, 15, 0, 25]
                },
                { text: 'Алгоритм программы:', style: 'subheader' },
                {
                    stack: algorithmLinesArray.map(line => ({
                        text: line,
                        style: 'algorithm',
                        preserveLeadingSpaces: true
                    })),
                    margin: [0, 5, 0, 0]
                }
            ],
            styles: {
                header: { fontSize: 18, bold: true, margin: [0, 0, 0, 10] },
                subheader: { fontSize: 14, bold: true, margin: [0, 10, 0, 5] },
                algorithm: { fontSize: 11, lineHeight: 1.3 }
            }
        };

        // --- Генерируем и скачиваем PDF ---
        let fileName = "Программа для Бота";
        const match = programNameFull.match(/=== Программа для Бота: (.+?) ===/);
        if (match && match[1]) {
            fileName = "Программа для Бота " + match[1].replace(/[^a-zA-Z0-9а-яА-ЯёЁ_\- ]/g, '_');
        } else {
            const rootBlock = workspace.getTopBlocks(false).find(b => b.type === 'bot_program');
            const botName = rootBlock ? (rootBlock.getFieldValue('PROGRAM_NAME')?.trim() || "Мой Бот") : "Мой Бот";
            fileName = "Программа для Бота " + botName;
        }
        pdfMake.createPdf(docDefinition).download(fileName + '.pdf');

    } catch (error) {
         console.error("Ошибка при экспорте в PDF:", error);
         // Простая попытка восстановления, если ошибка произошла до полной блокировки
         try {
             const blocklyDiv = document.getElementById('blocklyDiv');
             if(blocklyDiv) blocklyDiv.style.pointerEvents = '';
             const blocklyWorkspace = Blockly.getMainWorkspace();
             if (blocklyWorkspace) {
                 // Эти обработчики могут не восстановиться корректно, если ошибка была до их замены
                 // Лучше было бы сохранять их в замыкании внутри selectAreaAndCapture
             }
             const toolbox = document.getElementsByClassName('blocklyToolbox')[0];
             if (toolbox) toolbox.style.display = '';
             // Удаляем вспомогательные элементы, если они остались
             const overlayElement = document.getElementById('selection-overlay');
             const instructionElement = document.getElementById('selection-instruction');
             if (overlayElement) overlayElement.remove();
             if (instructionElement) instructionElement.remove();
             document.removeEventListener('mousedown', startSelection);
             document.removeEventListener('mousemove', updateSelection);
             document.removeEventListener('mouseup', endSelection);
         } catch (restoreError) { console.warn("Ошибка при восстановлении интерфейса после ошибки PDF:", restoreError); }

         alert(`Ошибка экспорта в PDF: ${error.message}\nПроверьте консоль браузера для деталей.`);
    }
};

// --- Экспорт в PNG (новая функция, использует общую функцию выделения) ---
document.getElementById('exportPngButton').onclick = async function () {
    try {
        if (typeof html2canvas === 'undefined') {
            throw new Error('Библиотека html2canvas не загружена');
        }

        // --- Получаем название программы для имени файла ---
        let fileNameBase = "Программа для бота";
        const rootBlock = workspace.getTopBlocks(false).find(b => b.type === 'bot_program');
        if (rootBlock) {
            const botName = rootBlock.getFieldValue('PROGRAM_NAME')?.trim();
            if (botName) {
                fileNameBase = `Программа для бота ${botName}`.replace(/[/\\?%*:|"<>]/g, '_');
            }
        }
        const fileName = `${fileNameBase}.png`;

        // --- Вызываем общую функцию выделения ---
        const canvas = await selectAreaAndCapture(); // <-- Используем общую функцию

        // --- Создаем ссылку для скачивания ---
        const link = document.createElement('a');
        link.download = fileName;
        link.href = canvas.toDataURL('image/png');
        link.click();

        alert(`Изображение сохранено как "${fileName}"`);

    } catch (error) {
        console.error("Ошибка при экспорте в PNG:", error);
        // Простая попытка восстановления, аналогично PDF
        try {
             const blocklyDiv = document.getElementById('blocklyDiv');
             if(blocklyDiv) blocklyDiv.style.pointerEvents = '';
             const blocklyWorkspace = Blockly.getMainWorkspace();
             if (blocklyWorkspace) { /* Попытка восстановления обработчиков */ }
             const toolbox = document.getElementsByClassName('blocklyToolbox')[0];
             if (toolbox) toolbox.style.display = '';
             const overlayElement = document.getElementById('selection-overlay');
             const instructionElement = document.getElementById('selection-instruction');
             if (overlayElement) overlayElement.remove();
             if (instructionElement) instructionElement.remove();
             document.removeEventListener('mousedown', startSelection);
             document.removeEventListener('mousemove', updateSelection);
             document.removeEventListener('mouseup', endSelection);
        } catch (restoreError) { console.warn("Ошибка при восстановлении интерфейса после ошибки PNG:", restoreError); }

        if (error.message !== 'Область слишком мала.') { // Не показываем alert для этой "ожидаемой" ошибки
             alert(`Ошибка экспорта в PNG: ${error.message}\nПроверьте консоль браузера для деталей.`);
        }
    }
};

// --- Вспомогательная функция trimCanvas (убедитесь, что она определена выше или ниже) ---
// Функция для обрезки белых полей с канваса
function trimCanvas(canvas) {
    const ctx = canvas.getContext('2d');
    const width = canvas.width;
    const height = canvas.height;
    const imageData = ctx.getImageData(0, 0, width, height);
    const data = imageData.data;

    let minX = width;
    let minY = height;
    let maxX = -1;
    let maxY = -1;

    for (let y = 0; y < height; y++) {
        for (let x = 0; x < width; x++) {
            const alpha = data[(y * width + x) * 4 + 3];
            if (alpha > 0) { // Если пиксель не полностью прозрачный
                minX = Math.min(minX, x);
                minY = Math.min(minY, y);
                maxX = Math.max(maxX, x);
                maxY = Math.max(maxY, y);
            }
        }
    }

    // Если ничего не найдено, вернуть оригинальный канвас
    if (minX > maxX || minY > maxY) {
         console.warn("trimCanvas: Не удалось найти непрозрачные пиксели. Возвращаю оригинальный канвас.");
         return canvas;
    }

    const trimmedWidth = maxX - minX + 1;
    const trimmedHeight = maxY - minY + 1;

    const trimmedCanvas = document.createElement('canvas');
    trimmedCanvas.width = trimmedWidth;
    trimmedCanvas.height = trimmedHeight;
    const trimmedCtx = trimmedCanvas.getContext('2d');
    trimmedCtx.drawImage(canvas, minX, minY, trimmedWidth, trimmedHeight, 0, 0, trimmedWidth, trimmedHeight);

    return trimmedCanvas;
}


</script>
</body>
</html>