<style>
canvas {
    image-rendering: -moz-crisp-edges;
    image-rendering: -webkit-optimize-contrast;
    image-rendering: crisp-edges;
    image-rendering: pixelated;
    -ms-interpolation-mode: nearest-neighbor;
}
</style>

<script>
document.addEventListener('DOMContentLoaded', function() {
    // Конфигурация изображений
    const IMAGE_BASE_URL = 'https://22176.hostkey.in:34172/pictures/bg_editor/';
    const TOKEN_IMAGES = {
        'ВП': 'water.png', 'ПВ': 'portal.png', 'ВК': 'water.png', 'КВ': 'stone.png',
        'Л': 'ice.png', 'Б': 'barell.png', 'Ц': 'goal.png', 'К↑': 'red_up.png',
        'К1': 'red_up.png', 'C↑': 'blue_up.png', 'C1': 'blue_up.png', 'З↑': 'green_up.png',
        'З1': 'green_up.png', 'Ж↑': 'yellow_up.png', 'Ж1': 'yellow_up.png',
        'ПЛ': 'line_straight.png', 'УЛ': 'line_corner.png', 'ВУТ': 'duck.png', 'ПРЖ': 'spring.png'
    };
    const FIELD_IMAGES = {
        "4x4": ["pole_4x4.png", "pole_4x4_alt.png"],
        "2x4_1": ["pole_2x4_1.png", "pole_2x4_1_alt.png"],
        "2x4_2": ["pole_2x4_2.png", "pole_2x4_2_alt.png"],
        "4x2_1": ["pole_4x2_1.png", "pole_4x2_1_alt.png"],
        "4x2_2": ["pole_4x2_2.png", "pole_4x2_2_alt.png"]
    };
    const PUZZLE_ICONS = {
        'lvl1': 'lvl1.png', 'lvl2': 'lvl2.png', 'lvl3': 'lvl3.png', 'lvl4': 'lvl4.png',
        'lvl5': 'lvl5.png', 'repeat2': 'repeat2.png', 'condition': 'condition.png',
        'attack': 'attack.png', 'defense': 'defense.png', 'bot1': 'bot1.png', 'bot2': 'bot2.png',
        'line1': 'line1.png', 'line2': 'line2.png', 'line3': 'line3.png', 'line4': 'line4.png',
        'line5': 'line5.png', 'line6': 'line6.png', 'lineN': 'lineN.png'
    };

    // Кэш для изображений
    const imageCache = {};

    // Функция для загрузки изображения с кэшированием
    function loadImage(url) {
        if (imageCache[url]) {
            return imageCache[url];
        }
        
        const promise = new Promise((resolve, reject) => {
            const img = new Image();
            img.onload = () => resolve(img);
            img.onerror = () => {
                console.error('Failed to load image:', url);
                reject(new Error(`Failed to load image: ${url}`));
            };
            img.src = url;
        });
        
        imageCache[url] = promise;
        return promise;
    }

    // Предварительная загрузка всех изображений
    async function preloadImages() {
        const allImages = [];
        
        // Все фоновые изображения
        Object.values(FIELD_IMAGES).forEach(variants => {
            variants.forEach(img => allImages.push(IMAGE_BASE_URL + img));
        });
        
        // Все изображения токенов
        Object.values(TOKEN_IMAGES).forEach(img => {
            allImages.push(IMAGE_BASE_URL + img);
        });
        
        // Все иконки головоломок
        Object.values(PUZZLE_ICONS).forEach(img => {
            allImages.push(IMAGE_BASE_URL + img);
        });
        
        // Загружаем все уникальные изображения
        const uniqueImages = [...new Set(allImages)];
        await Promise.all(uniqueImages.map(url => 
            loadImage(url).catch(e => console.error('Preload error:', url, e))
        ));
    }

    // Основная функция рендеринга
    function findAndRenderJSON() {
        document.querySelectorAll('.t005__text[field="text"]').forEach(element => {
            if (element.dataset.jsonRendered) return;
            
            const text = element.textContent.trim();
            if (text.startsWith('{') && text.endsWith('}')) {
                try {
                    const jsonData = JSON.parse(text);
                    if (jsonData.grid) {
                        renderGameContainer(jsonData, element);
                    }
                } catch (e) {
                    console.error('JSON parse error:', e);
                }
            }
        });
    }

    // Создание canvas для слоя
    function createLayerCanvas(bounds, cellSize) {
        const canvas = document.createElement('canvas');
        canvas.width = bounds.width * cellSize;
        canvas.height = bounds.height * cellSize;
        canvas.style.position = 'absolute';
        canvas.style.top = '0';
        canvas.style.left = '0';
        return canvas;
    }

    // Создание контейнера для рендеринга
    async function renderGameContainer(jsonData, originalElement) {
        // Находим соседний блок для названия и описания
        const parentCol = originalElement.closest('.t-col');
        const infoCol = parentCol.nextElementSibling;
        const infoContainer = infoCol?.querySelector('.t005__text[field="text2"]');
        
        // Очищаем блок с JSON
        originalElement.innerHTML = '';
        originalElement.dataset.jsonRendered = 'true';
        
        // Рассчитываем размеры поля
        const {bounds, cellSize} = calculateFieldSize(jsonData, originalElement.offsetWidth);
        
        // Создаем контейнер для масштабирования
        const scaleContainer = document.createElement('div');
        scaleContainer.style.position = 'relative';
        scaleContainer.style.width = `${bounds.width * cellSize}px`;
        scaleContainer.style.height = `${bounds.height * cellSize}px`;
        scaleContainer.style.margin = '0 auto';
        scaleContainer.style.cursor = 'pointer';
        scaleContainer.style.transition = 'transform 0.2s';
        
        // Создаем canvas для каждого слоя
        const layersContainer = document.createElement('div');
        layersContainer.style.position = 'relative';
        layersContainer.style.width = '100%';
        layersContainer.style.height = '100%';
        
        // Слой 0 - фоновые поля
        const layer0 = createLayerCanvas(bounds, cellSize);
        
        // Слои 1-3 для жетонов
        const layer1 = createLayerCanvas(bounds, cellSize);
        const layer2 = createLayerCanvas(bounds, cellSize);
        const layer3 = createLayerCanvas(bounds, cellSize);
        
        // Улучшаем четкость при масштабировании
        [layer0, layer1, layer2, layer3].forEach(canvas => {
            canvas.style.imageRendering = 'pixelated';
        });

        layersContainer.appendChild(layer0);
        layersContainer.appendChild(layer1);
        layersContainer.appendChild(layer2);
        layersContainer.appendChild(layer3);
        
        // Рендерим сетку на отдельном canvas
        const gridCanvas = createLayerCanvas(bounds, cellSize);
        gridCanvas.style.imageRendering = 'pixelated';
        renderGridLayer(gridCanvas.getContext('2d'), bounds, cellSize);
        layersContainer.appendChild(gridCanvas);
        
        scaleContainer.appendChild(layersContainer);
        
        // Создаем контейнер для панели головоломок
        let puzzlePanelContainer = null;
        if (jsonData.editorMode === 'puzzle' && jsonData.puzzleIcons) {
            puzzlePanelContainer = document.createElement('div');
            const puzzlePanel = await renderPuzzlePanel(jsonData.puzzleIcons, cellSize * 0.5);
            puzzlePanelContainer.appendChild(puzzlePanel);
            originalElement.appendChild(puzzlePanelContainer);
        }
        
        originalElement.appendChild(scaleContainer);

        // Рендерим каждый слой
        await renderBackgroundLayer(layer0.getContext('2d'), jsonData, bounds, cellSize);
        await renderTokenLayer(layer1.getContext('2d'), jsonData, bounds, cellSize, 0);
        await renderTokenLayer(layer2.getContext('2d'), jsonData, bounds, cellSize, 1);
        await renderTokenLayer(layer3.getContext('2d'), jsonData, bounds, cellSize, 2);

        // Флаг увеличенного состояния
        let isZoomed = false;
        let overlay = null;
        
        // Обработчик клика для увеличения/уменьшения
        scaleContainer.addEventListener('click', async function() {
            if (isZoomed) {
                document.body.removeChild(overlay);
                isZoomed = false;
                overlay = null;
                return;
            }

            const originalWidth = bounds.width * cellSize;
            const originalHeight = bounds.height * cellSize;
            const isMobile = window.innerWidth <= 768;
            const pixelRatio = window.devicePixelRatio || 1;
            
            // Настройки масштабирования
            let scale, displayWidth, displayHeight, canvasWidth, canvasHeight;
            
            if (isMobile) {
                scale = 2;
                displayWidth = originalWidth * scale;
                displayHeight = originalHeight * scale;
                canvasWidth = originalWidth * scale * pixelRatio;
                canvasHeight = originalHeight * scale * pixelRatio;
            } else {
                const maxWidth = window.innerWidth * 0.8;
                const maxHeight = window.innerHeight * 0.8;
                scale = Math.min(maxWidth / originalWidth, maxHeight / originalHeight);
                displayWidth = originalWidth * scale;
                displayHeight = originalHeight * scale;
                canvasWidth = originalWidth * scale * pixelRatio;
                canvasHeight = originalHeight * scale * pixelRatio;
            }

            // Создаем оверлей
            overlay = document.createElement('div');
            overlay.style.position = 'fixed';
            overlay.style.top = '0';
            overlay.style.left = '0';
            overlay.style.width = '100%';
            overlay.style.height = '100%';
            overlay.style.backgroundColor = 'rgba(0,0,0,0.9)';
            overlay.style.zIndex = '1000';
            overlay.style.overflow = isMobile ? 'auto' : 'hidden';
            overlay.style.cursor = 'pointer';
            overlay.style.display = 'flex';
            overlay.style.justifyContent = 'center';
            overlay.style.alignItems = 'center';
            overlay.style.webkitOverflowScrolling = 'touch';

            // Кнопка закрытия
            const closeBtn = document.createElement('div');
            closeBtn.innerHTML = '&times;';
            closeBtn.style.position = 'fixed';
            closeBtn.style.top = '20px';
            closeBtn.style.right = '20px';
            closeBtn.style.color = 'white';
            closeBtn.style.fontSize = '30px';
            closeBtn.style.width = '40px';
            closeBtn.style.height = '40px';
            closeBtn.style.display = 'flex';
            closeBtn.style.alignItems = 'center';
            closeBtn.style.justifyContent = 'center';
            closeBtn.style.cursor = 'pointer';
            closeBtn.style.zIndex = '1001';
            closeBtn.style.textShadow = '0 0 5px black';
            closeBtn.style.backgroundColor = 'rgba(0,0,0,0.5)';
            closeBtn.style.borderRadius = '50%';

            // Основной контейнер
            const zoomContainer = document.createElement('div');
            zoomContainer.style.position = 'relative';
            zoomContainer.style.width = `${displayWidth}px`;
            zoomContainer.style.minHeight = `${displayHeight}px`;
            zoomContainer.style.backgroundColor = 'white';
            zoomContainer.style.borderRadius = '8px';
            zoomContainer.style.boxShadow = '0 0 20px rgba(0,0,0,0.5)';
            zoomContainer.style.display = 'flex';
            zoomContainer.style.flexDirection = 'column';
            zoomContainer.style.alignItems = 'center';
            zoomContainer.style.padding = '20px';
            zoomContainer.style.margin = isMobile ? '20px' : '0';
            zoomContainer.style.transform = 'translateZ(0)';

            // Панель головоломок
            if (puzzlePanelContainer && jsonData.puzzleIcons) {
                const puzzlePanel = await renderPuzzlePanel(
                    jsonData.puzzleIcons, 
                    cellSize * 0.5 * (isMobile ? 2 : scale)
                );
                puzzlePanel.style.backgroundColor = 'rgba(255,255,255,0.9)';
                puzzlePanel.style.padding = '10px';
                puzzlePanel.style.borderRadius = '5px';
                puzzlePanel.style.marginBottom = '15px';
                puzzlePanel.style.boxShadow = '0 2px 5px rgba(0,0,0,0.2)';
                puzzlePanel.style.transform = 'translateZ(0)';
                zoomContainer.appendChild(puzzlePanel);
            }

            // Canvas с высоким разрешением
            const zoomCanvas = document.createElement('canvas');
            zoomCanvas.width = canvasWidth;
            zoomCanvas.height = canvasHeight;
            zoomCanvas.style.width = `${displayWidth}px`;
            zoomCanvas.style.height = `${displayHeight}px`;
            zoomCanvas.style.imageRendering = 'pixelated';
            zoomCanvas.style.transform = 'translateZ(0)';

            // Рендеринг с высоким качеством
            const ctx = zoomCanvas.getContext('2d');
            ctx.scale(scale * pixelRatio, scale * pixelRatio);
            ctx.clearRect(0, 0, canvasWidth, canvasHeight);
            await renderBackgroundLayer(ctx, jsonData, bounds, cellSize);
            await renderTokenLayer(ctx, jsonData, bounds, cellSize, 0);
            await renderTokenLayer(ctx, jsonData, bounds, cellSize, 1);
            await renderTokenLayer(ctx, jsonData, bounds, cellSize, 2);
            renderGridLayer(ctx, bounds, cellSize);

            zoomContainer.appendChild(zoomCanvas);
            overlay.appendChild(zoomContainer);
            overlay.appendChild(closeBtn);
            document.body.appendChild(overlay);
            isZoomed = true;

            // Центрирование и скролл
            if (isMobile) {
                overlay.scrollTo({
                    top: (zoomContainer.offsetHeight - window.innerHeight) / 2,
                    left: (zoomContainer.offsetWidth - window.innerWidth) / 2,
                    behavior: 'auto'
                });
            }

            // Закрытие
            function closeOverlay() {
                document.body.removeChild(overlay);
                isZoomed = false;
                overlay = null;
            }

            overlay.addEventListener('click', function(e) {
                if (e.target === overlay || e.target === closeBtn) {
                    closeOverlay();
                }
            });
        });

        // Добавляем название и описание уровня в соседний блок
        if (infoContainer) {
            infoContainer.innerHTML = '';
            
            if (jsonData.name) {
                const title = document.createElement('h3');
                title.textContent = jsonData.name;
                title.style.margin = '0 0 10px 0';
                title.style.fontSize = '1.2em';
                infoContainer.appendChild(title);
            }
            
            if (jsonData.description) {
                const desc = document.createElement('p');
                desc.textContent = jsonData.description;
                desc.style.margin = '0';
                desc.style.fontSize = '0.9em';
                infoContainer.appendChild(desc);
            }
            
            // Добавляем кнопку сохранения JSON
            const saveBtn = document.createElement('button');
            saveBtn.textContent = 'Сохранить уровень';
            Object.assign(saveBtn.style, {
                marginTop: '15px',
                padding: '8px 15px',
                backgroundColor: '#4CAF50',
                color: 'white',
                border: 'none',
                borderRadius: '4px',
                cursor: 'pointer',
                fontSize: '0.9em'
            });
            
            saveBtn.addEventListener('click', function() {
                const jsonStr = JSON.stringify(jsonData, null, 2);
                const blob = new Blob([jsonStr], {type: 'application/json'});
                const url = URL.createObjectURL(blob);
                
                const a = document.createElement('a');
                a.href = url;
                a.download = (jsonData.name || 'level') + '.json';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            });
            
            infoContainer.appendChild(saveBtn);
        }
    }

    // Рендерим сетку
    function renderGridLayer(ctx, bounds, cellSize) {
        ctx.strokeStyle = 'rgba(200, 200, 200, 0.5)';
        ctx.lineWidth = 1;
        
        // Вертикальные линии
        for (let x = 0; x <= bounds.width; x++) {
            ctx.beginPath();
            ctx.moveTo(x * cellSize, 0);
            ctx.lineTo(x * cellSize, bounds.height * cellSize);
            ctx.stroke();
        }
        
        // Горизонтальные линии
        for (let y = 0; y <= bounds.height; y++) {
            ctx.beginPath();
            ctx.moveTo(0, y * cellSize);
            ctx.lineTo(bounds.width * cellSize, y * cellSize);
            ctx.stroke();
        }
    }

    // Расчет размеров поля
    function calculateFieldSize(jsonData, containerWidth) {
        let minRow = 9, maxRow = 0, minCol = 9, maxCol = 0;
        let hasContent = false;

        // Проверяем токены
        for (let row = 0; row < 10; row++) {
            for (let col = 0; col < 10; col++) {
                if (jsonData.grid[row][col].some(layer => layer !== '')) {
                    hasContent = true;
                    minRow = Math.min(minRow, row);
                    maxRow = Math.max(maxRow, row);
                    minCol = Math.min(minCol, col);
                    maxCol = Math.max(maxCol, col);
                }
            }
        }

        // Проверяем фоновые поля
        if (jsonData.checkboxes) {
            Object.entries(jsonData.checkboxes).forEach(([field, checked]) => {
                if (checked) {
                    hasContent = true;
                    const pos = jsonData.userFieldPositions?.[field] || getDefaultFieldPosition(field);
                    const size = getFieldSize(field);
                    minRow = Math.min(minRow, pos.row);
                    maxRow = Math.max(maxRow, pos.row + size.height - 1);
                    minCol = Math.min(minCol, pos.col);
                    maxCol = Math.max(maxCol, pos.col + size.width - 1);
                }
            });
        }

        // Если поле пустое, показываем центральную область
        if (!hasContent) {
            minRow = 3; maxRow = 6;
            minCol = 3; maxCol = 6;
        }

        // Рассчитываем размеры поля в клетках
        const widthInCells = maxCol - minCol + 1;
        const heightInCells = maxRow - minRow + 1;

        // Рассчитываем оптимальный размер клетки (максимум 150px)
        const availableWidth = containerWidth - 40;
        const cellSize = Math.min(150, Math.max(30, Math.floor(availableWidth / widthInCells)));

        return {
            bounds: {
                minRow, maxRow, minCol, maxCol,
                width: widthInCells,
                height: heightInCells
            },
            cellSize
        };
    }

    // Позиции полей по умолчанию
    function getDefaultFieldPosition(field) {
        const positions = {
            "4x4": {row: 0, col: 3},
            "2x4_1": {row: 0, col: 0},
            "2x4_2": {row: 0, col: 8},
            "4x2_1": {row: 0, col: 0},
            "4x2_2": {row: 0, col: 6}
        };
        return positions[field] || {row: 0, col: 0};
    }

    // Размеры полей
    function getFieldSize(field) {
        const sizes = {
            "4x4": {width: 4, height: 4},
            "2x4_1": {width: 2, height: 4},
            "2x4_2": {width: 2, height: 4},
            "4x2_1": {width: 4, height: 2},
            "4x2_2": {width: 4, height: 2}
        };
        return sizes[field] || {width: 1, height: 1};
    }

    // Рендеринг фонового слоя (поля)
    async function renderBackgroundLayer(ctx, jsonData, bounds, cellSize) {
        const {minRow, minCol} = bounds;
        
        if (!jsonData.checkboxes) return;

        const renderPromises = [];
        
        Object.entries(jsonData.checkboxes).forEach(([field, checked]) => {
            if (checked) {
                const pos = jsonData.userFieldPositions?.[field] || getDefaultFieldPosition(field);
                const size = getFieldSize(field);
                
                // Проверяем, попадает ли поле в видимую область
                if (pos.row + size.height <= minRow || pos.row >= minRow + bounds.height ||
                    pos.col + size.width <= minCol || pos.col >= minCol + bounds.width) {
                    return;
                }

                const imageIndex = jsonData.fieldImageIndices?.[field] || 0;
                const imageUrl = IMAGE_BASE_URL + FIELD_IMAGES[field][imageIndex];
                
                renderPromises.push(
                    loadImage(imageUrl).then(img => {
                        ctx.drawImage(
                            img,
                            (pos.col - minCol) * cellSize,
                            (pos.row - minRow) * cellSize,
                            size.width * cellSize,
                            size.height * cellSize
                        );
                    }).catch(e => {
                        console.error('Error rendering background:', field, e);
                    })
                );
            }
        });
        
        await Promise.all(renderPromises);
    }

    // Рендеринг слоя с токенами
    async function renderTokenLayer(ctx, jsonData, bounds, cellSize, layerIndex) {
        const {minRow, minCol} = bounds;
        const renderPromises = [];
        
        for (let row = minRow; row <= minRow + bounds.height - 1; row++) {
            for (let col = minCol; col <= minCol + bounds.width - 1; col++) {
                const tokenName = jsonData.grid[row][col][layerIndex];
                if (tokenName) {
                    const imageUrl = IMAGE_BASE_URL + TOKEN_IMAGES[tokenName];
                    
                    renderPromises.push(
                        loadImage(imageUrl).then(img => {
                            // Позиция токена
                            const x = (col - minCol + 0.5) * cellSize;
                            const y = (row - minRow + 0.5) * cellSize;
                            
                            // Поворот
                            const rotationKey = `rotation_${row}_${col}_${tokenName}_layer${layerIndex+1}`;
                            const rotation = jsonData.rotations?.[rotationKey] || 0;
                            
                            // Размер токена (80% от размера ячейки)
                            const size = cellSize * 0.8;
                            
                            // Сохраняем текущее состояние canvas
                            ctx.save();
                            
                            // Перемещаем начало координат в центр токена
                            ctx.translate(x, y);
                            
                            // Применяем поворот
                            if (rotation) {
                                ctx.rotate(rotation * Math.PI / 180);
                            }
                            
                            // Рисуем изображение
                            ctx.drawImage(
                                img,
                                -size/2, -size/2,
                                size, size
                            );
                            
                            // Восстанавливаем состояние canvas
                            ctx.restore();
                        }).catch(e => {
                            console.error('Error rendering token:', tokenName, e);
                        })
                    );
                }
            }
        }
        
        await Promise.all(renderPromises);
    }

    // Рендерим панель головоломок
    async function renderPuzzlePanel(puzzleIcons, iconSize) {
        const panel = document.createElement('div');
        Object.assign(panel.style, {
            display: 'flex',
            justifyContent: 'center',
            gap: '10px',
            marginBottom: '15px',
            flexWrap: 'wrap'
        });

        const iconPromises = puzzleIcons.map(async iconKey => {
            if (iconKey) {
                const imageUrl = IMAGE_BASE_URL + PUZZLE_ICONS[iconKey];
                try {
                    const img = await loadImage(imageUrl);
                    const icon = document.createElement('img');
                    icon.src = img.src;
                    Object.assign(icon.style, {
                        width: `${iconSize}px`,
                        height: `${iconSize}px`,
                        objectFit: 'contain',
                        border: '2px solid #ccc',
                        borderRadius: '5px',
                        padding: '2px',
                        backgroundColor: 'white'
                    });
                    panel.appendChild(icon);
                } catch (e) {
                    console.error('Failed to load puzzle icon:', iconKey, e);
                }
            }
        });

        await Promise.all(iconPromises);
        return panel;
    }

    // Инициализация
    preloadImages().then(() => {
        findAndRenderJSON();
        
        // Обработка динамического контента
        new MutationObserver(findAndRenderJSON).observe(document.body, {
            childList: true,
            subtree: true
        });
    }).catch(e => {
        console.error('Image preloading failed:', e);
        findAndRenderJSON();
    });
});
</script>